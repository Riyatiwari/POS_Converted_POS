!function () { function t(t, e) { var i; for (i in t || (t = {}), e) t[i] = e[i]; return t } function e() { var t, e, i = arguments, n = {}, s = function (t, e) { var i, n; for (n in "object" != typeof t && (t = {}), e) e.hasOwnProperty(n) && (i = e[n], t[n] = i && "object" == typeof i && "[object Array]" !== Object.prototype.toString.call(i) && "renderTo" !== n && "number" != typeof i.nodeType ? s(t[n] || {}, i) : e[n]); return t }; for (!0 === i[0] && (n = i[1], i = Array.prototype.slice.call(i, 2)), e = i.length, t = 0; t < e; t++)n = s(n, i[t]); return n } function i(t, e) { return parseInt(t, e || 10) } function n(t) { return "string" == typeof t } function s(t) { return "object" == typeof t } function o(t) { return "[object Array]" === Object.prototype.toString.call(t) } function r(t) { return "number" == typeof t } function a(t) { return lt.log(t) / lt.LN10 } function h(t) { return lt.pow(10, t) } function l(t, e) { for (var i = t.length; i--;)if (t[i] === e) { t.splice(i, 1); break } } function c(t) { return t !== H && null !== t } function d(t, e, i) { var o, r; if (n(e)) c(i) ? t.setAttribute(e, i) : t && t.getAttribute && (r = t.getAttribute(e)); else if (c(e) && s(e)) for (o in e) t.setAttribute(o, e[o]); return r } function p(t) { return o(t) ? t : [t] } function u() { var t, e, i = arguments, n = i.length; for (t = 0; t < n; t++)if (null != (e = i[t])) return e } function f(e, i) { wt && !Ct && i && i.opacity !== H && (i.filter = "alpha(opacity=" + 100 * i.opacity + ")"), t(e.style, i) } function g(e, i, n, s, o) { return e = at.createElement(e), i && t(e, i), o && f(e, { padding: 0, border: Et, margin: 0 }), n && f(e, n), s && s.appendChild(e), e } function m(e, i) { var n = function () { }; return t(n.prototype = new e, i), n } function y(t, e, n, s) { var o = N.lang, r = (t = +t || 0, -1 === e ? (t.toString().split(".")[1] || "").length : isNaN(e = gt(e)) ? 2 : e), a = (e = void 0 === n ? o.decimalPoint : n, s = void 0 === s ? o.thousandsSep : s, o = t < 0 ? "-" : "", (n = String(i(t = gt(t).toFixed(r)))).length > 3 ? n.length % 3 : 0); return o + (a ? n.substr(0, a) + s : "") + n.substr(a).replace(/(\d{3})(?=\d)/g, "$1" + s) + (r ? e + gt(t - n).toFixed(r).slice(2) : "") } function x(t, e) { return Array((e || 2) + 1 - String(t).length).join(0) + t } function v(t, e, i) { var n = t[e]; t[e] = function () { var t = Array.prototype.slice.call(arguments); return t.unshift(n), i.apply(this, t) } } function b(t, e) { for (var i, n, s, o, r, a = "{", h = !1, l = []; -1 !== (a = t.indexOf(a));) { if (i = t.slice(0, a), h) { for (r = (s = (n = i.split(":")).shift().split(".")).length, i = e, o = 0; o < r; o++)i = i[s[o]]; n.length && (n = n.join(":"), s = /\.([0-9])/, o = N.lang, r = void 0, /f$/.test(n) ? (r = (r = n.match(s)) ? r[1] : -1, null !== i && (i = y(i, r, o.decimalPoint, n.indexOf(",") > -1 ? o.thousandsSep : ""))) : i = F(n, i)) } l.push(i), t = t.slice(a + 1), a = (h = !h) ? "}" : "{" } return l.push(t), l.join("") } function k(t) { return lt.pow(10, dt(lt.log(t) / lt.LN10)) } function w(t, e, i, n) { var s; for (s = t / (i = u(i, 1)), e || (e = [1, 2, 2.5, 5, 10], n && !1 === n.allowDecimals && (1 === i ? e = [1, 2, 5, 10] : i <= .1 && (e = [1 / i]))), n = 0; n < e.length && (t = e[n], !(s <= (e[n] + (e[n + 1] || e[n])) / 2)); n++); return t *= i } function S() { this.symbol = this.color = 0 } function T(t, e) { var i, n, s = t.length; for (n = 0; n < s; n++)t[n].ss_i = n; for (t.sort(function (t, n) { return 0 === (i = e(t, n)) ? t.ss_i - n.ss_i : i }), n = 0; n < s; n++)delete t[n].ss_i } function P(t) { for (var e = t.length, i = t[0]; e--;)t[e] < i && (i = t[e]); return i } function A(t) { for (var e = t.length, i = t[0]; e--;)t[e] > i && (i = t[e]); return i } function L(t, e) { for (var i in t) t[i] && t[i] !== e && t[i].destroy && t[i].destroy(), delete t[i] } function C(t) { Y || (Y = g(Xt)), t && Y.appendChild(t), Y.innerHTML = "" } function M(t, e) { var i = "Highcharts error #" + t + ": www.highcharts.com/errors/" + t; if (e) throw i; ht.console && console.log(i) } function D(t) { return parseFloat(t.toPrecision(14)) } function I(t, e) { _ = u(t, e.animation) } function O() { var t = N.global.useUTC, e = t ? "getUTC" : "get", i = t ? "setUTC" : "set"; Z = 6e4 * (t && N.global.timezoneOffset || 0), U = t ? Date.UTC : function (t, e, i, n, s, o) { return new Date(t, e, u(i, 1), u(n, 0), u(s, 0), u(o, 0)).getTime() }, K = e + "Minutes", $ = e + "Hours", q = e + "Day", J = e + "Date", Q = e + "Month", tt = e + "FullYear", et = i + "Minutes", it = i + "Hours", nt = i + "Date", st = i + "Month", ot = i + "FullYear" } function z() { } function B(t, e, i, n) { this.axis = t, this.pos = e, this.type = i || "", this.isNew = !0, !i && !n && this.addLabel() } function R() { this.init.apply(this, arguments) } function X() { this.init.apply(this, arguments) } function E(t, e, i, n, s) { var o = t.chart.inverted; this.axis = t, this.isNegative = i, this.options = e, this.x = n, this.total = null, this.points = {}, this.stack = s, this.alignOptions = { align: e.align || (o ? i ? "left" : "right" : "center"), verticalAlign: e.verticalAlign || (o ? "middle" : i ? "bottom" : "top"), y: u(e.y, o ? 4 : i ? 14 : -6), x: u(e.x, o ? i ? -6 : 6 : 0) }, this.textAlign = e.textAlign || (o ? i ? "right" : "left" : "center") } var H, G, W, Y, N, F, _, j, V, U, Z, K, $, q, J, Q, tt, et, it, nt, st, ot, rt, at = document, ht = window, lt = Math, ct = lt.round, dt = lt.floor, pt = lt.ceil, ut = lt.max, ft = lt.min, gt = lt.abs, mt = lt.cos, yt = lt.sin, xt = lt.PI, vt = 2 * xt / 360, bt = navigator.userAgent, kt = ht.opera, wt = /msie/i.test(bt) && !kt, St = 8 === at.documentMode, Tt = /AppleWebKit/.test(bt), Pt = /Firefox/.test(bt), At = /(Mobile|Android|Windows Phone)/.test(bt), Lt = "http://www.w3.org/2000/svg", Ct = !!at.createElementNS && !!at.createElementNS(Lt, "svg").createSVGRect, Mt = Pt && parseInt(bt.split("Firefox/")[1], 10) < 4, Dt = !Ct && !wt && !!at.createElement("canvas").getContext, It = {}, Ot = 0, zt = function () { }, Bt = [], Rt = 0, Xt = "div", Et = "none", Ht = /^[0-9]+$/, Gt = "stroke-width", Wt = {}, Yt = ht.Highcharts = ht.Highcharts ? M(16, !0) : {}; F = function (e, i, n) { if (!c(i) || isNaN(i)) return "Invalid date"; e = u(e, "%Y-%m-%d %H:%M:%S"); var s, o = (f = new Date(i - Z))[$](), r = f[q](), a = f[J](), h = f[Q](), l = f[tt](), d = N.lang, p = d.weekdays, f = t({ a: p[r].substr(0, 3), A: p[r], d: x(a), e: a, b: d.shortMonths[h], B: d.months[h], m: x(h + 1), y: l.toString().substr(2, 2), Y: l, H: x(o), I: x(o % 12 || 12), l: o % 12 || 12, M: x(f[K]()), p: o < 12 ? "AM" : "PM", P: o < 12 ? "am" : "pm", S: x(f.getSeconds()), L: x(ct(i % 1e3), 3) }, Yt.dateFormats); for (s in f) for (; -1 !== e.indexOf("%" + s);)e = e.replace("%" + s, "function" == typeof f[s] ? f[s](i) : f[s]); return n ? e.substr(0, 1).toUpperCase() + e.substr(1) : e }, S.prototype = { wrapColor: function (t) { this.color >= t && (this.color = 0) }, wrapSymbol: function (t) { this.symbol >= t && (this.symbol = 0) } }, V = function () { for (var t = 0, e = arguments, i = e.length, n = {}; t < i; t++)n[e[t++]] = e[t]; return n }("millisecond", 1, "second", 1e3, "minute", 6e4, "hour", 36e5, "day", 864e5, "week", 6048e5, "month", 26784e5, "year", 31556952e3), j = { init: function (t, e, i) { e = e || ""; var n, s, o, r = t.shift, a = e.indexOf("C") > -1, h = a ? 7 : 3, l = (e = e.split(" "), i = [].concat(i), function (t) { for (n = t.length; n--;)"M" === t[n] && t.splice(n + 1, 0, t[n + 1], t[n + 2], t[n + 1], t[n + 2]) }); if (a && (l(e), l(i)), t.isArea && (s = e.splice(e.length - 6, 6), o = i.splice(i.length - 6, 6)), r <= i.length / h && e.length === i.length) for (; r--;)i = [].concat(i).splice(0, h).concat(i); if (t.shift = 0, e.length) for (t = i.length; e.length < t;)r = [].concat(e).splice(e.length - h, h), a && (r[h - 6] = r[h - 2], r[h - 5] = r[h - 1]), e = e.concat(r); return s && (e = e.concat(s), i = i.concat(o)), [e, i] }, step: function (t, e, i, n) { var s = [], o = t.length; if (1 === i) s = n; else if (o === e.length && i < 1) for (; o--;)n = parseFloat(t[o]), s[o] = isNaN(n) ? t[o] : i * parseFloat(e[o] - n) + n; else s = e; return s } }, rt = ht.jQuery, ht.HighchartsAdapter = ht.HighchartsAdapter || rt && { init: function (t) { var e, i = rt.fx, s = i.step, o = rt.Tween, r = o && o.propHooks; e = rt.cssHooks.opacity, rt.extend(rt.easing, { easeOutQuad: function (t, e, i, n, s) { return -n * (e /= s) * (e - 2) + i } }), rt.each(["cur", "_default", "width", "height", "opacity"], function (t, e) { var n, a = s; "cur" === e ? a = i.prototype : "_default" === e && o && (a = r[e], e = "set"), (n = a[e]) && (a[e] = function (i) { var s; if ("align" !== (i = t ? i : this).prop) return (s = i.elem).attr ? s.attr(i.prop, "cur" === e ? H : i.now) : n.apply(this, arguments) }) }), v(e, "get", function (t, e, i) { return e.attr ? e.opacity || 0 : t.call(this, e, i) }), e = function (e) { var i, n = e.elem; e.started || (i = t.init(n, n.d, n.toD), e.start = i[0], e.end = i[1], e.started = !0), n.attr("d", t.step(e.start, e.end, e.pos, n.toD)) }, o ? r.d = { set: e } : s.d = e, this.each = Array.prototype.forEach ? function (t, e) { return Array.prototype.forEach.call(t, e) } : function (t, e) { for (var i = 0, n = t.length; i < n; i++)if (!1 === e.call(t[i], t[i], i, t)) return i }, rt.fn.highcharts = function () { var t, e, i = "Chart", s = arguments; return this[0] && (n(s[0]) && (i = s[0], s = Array.prototype.slice.call(s, 1)), (t = s[0]) !== H && (t.chart = t.chart || {}, t.chart.renderTo = this[0], new Yt[i](t, s[1]), e = this), t === H && (e = Bt[d(this[0], "data-highcharts-chart")])), e } }, getScript: rt.getScript, inArray: rt.inArray, adapterRun: function (t, e) { return rt(t)[e]() }, grep: rt.grep, map: function (t, e) { for (var i = [], n = 0, s = t.length; n < s; n++)i[n] = e.call(t[n], t[n], n, t); return i }, offset: function (t) { return rt(t).offset() }, addEvent: function (t, e, i) { rt(t).bind(e, i) }, removeEvent: function (t, e, i) { var n = at.removeEventListener ? "removeEventListener" : "detachEvent"; at[n] && t && !t[n] && (t[n] = function () { }), rt(t).unbind(e, i) }, fireEvent: function (e, i, n, s) { var o, r = rt.Event(i), a = "detached" + i; !wt && n && (delete n.layerX, delete n.layerY, delete n.returnValue), t(r, n), e[i] && (e[a] = e[i], e[i] = null), rt.each(["preventDefault", "stopPropagation"], function (t, e) { var i = r[e]; r[e] = function () { try { i.call(r) } catch (t) { "preventDefault" === e && (o = !0) } } }), rt(e).trigger(r), e[a] && (e[i] = e[a], e[a] = null), s && !r.isDefaultPrevented() && !o && s(r) }, washMouseEvent: function (t) { var e = t.originalEvent || t; return e.pageX === H && (e.pageX = t.pageX, e.pageY = t.pageY), e }, animate: function (t, e, i) { var n = rt(t); t.style || (t.style = {}), e.d && (t.toD = e.d, e.d = 1), n.stop(), e.opacity !== H && t.attr && (e.opacity += "px"), n.animate(e, i) }, stop: function (t) { rt(t).stop() } }; var Nt = (ne = ht.HighchartsAdapter) || {}; ne && ne.init.call(ne, j); var Ft = Nt.adapterRun, _t = Nt.getScript, jt = Nt.inArray, Vt = Nt.each, Ut = Nt.grep, Zt = Nt.offset, Kt = Nt.map, $t = Nt.addEvent, qt = Nt.removeEvent, Jt = Nt.fireEvent, Qt = Nt.washMouseEvent, te = Nt.animate, ee = Nt.stop, ie = (Nt = { enabled: !0, x: 0, y: 15, style: { color: "#606060", cursor: "default", fontSize: "11px" } }, (N = { colors: "#7cb5ec,#434348,#90ed7d,#f7a35c,#8085e9,#f15c80,#e4d354,#8085e8,#8d4653,#91e8e1".split(","), symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { loading: "Loading...", months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","), shortMonths: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","), weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","), decimalPoint: ".", numericSymbols: "k,M,G,T,P,E".split(","), resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: "," }, global: { useUTC: !0, canvasToolsURL: "http://code.highcharts.com/4.0.1/modules/canvas-tools.js", VMLRadialGradientURL: "http://code.highcharts.com/4.0.1/gfx/vml-radial-gradient.png" }, chart: { borderColor: "#4572A7", borderRadius: 0, defaultSeriesType: "line", ignoreHiddenSeries: !0, spacing: [10, 10, 15, 10], backgroundColor: "#FFFFFF", plotBorderColor: "#C0C0C0", resetZoomButton: { theme: { zIndex: 20 }, position: { align: "right", x: -10, y: 10 } } }, title: { text: "Chart title", align: "center", margin: 15, style: { color: "#333333", fontSize: "18px" } }, subtitle: { text: "", align: "center", style: { color: "#555555" } }, plotOptions: { line: { allowPointSelect: !1, showCheckbox: !1, animation: { duration: 1e3 }, events: {}, lineWidth: 2, marker: { lineWidth: 0, radius: 4, lineColor: "#FFFFFF", states: { hover: { enabled: !0 }, select: { fillColor: "#FFFFFF", lineColor: "#000000", lineWidth: 2 } } }, point: { events: {} }, dataLabels: e(Nt, { align: "center", enabled: !1, formatter: function () { return null === this.y ? "" : y(this.y, -1) }, verticalAlign: "bottom", y: 0 }), cropThreshold: 300, pointRange: 0, states: { hover: { marker: {}, halo: { size: 10, opacity: .25 } }, select: { marker: {} } }, stickyTracking: !0, turboThreshold: 1e3 } }, labels: { style: { position: "absolute", color: "#3E576F" } }, legend: { enabled: !0, align: "center", layout: "horizontal", labelFormatter: function () { return this.name }, borderColor: "#909090", borderRadius: 0, navigation: { activeColor: "#274b6d", inactiveColor: "#CCC" }, shadow: !1, itemStyle: { color: "#333333", fontSize: "12px", fontWeight: "bold" }, itemHoverStyle: { color: "#000" }, itemHiddenStyle: { color: "#CCC" }, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { fontWeight: "bold" } } }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "1em" }, style: { position: "absolute", backgroundColor: "white", opacity: .5, textAlign: "center" } }, tooltip: { enabled: !0, animation: Ct, backgroundColor: "rgba(249, 249, 249, .85)", borderWidth: 1, borderRadius: 3, dateTimeLabelFormats: { millisecond: "%A, %b %e, %H:%M:%S.%L", second: "%A, %b %e, %H:%M:%S", minute: "%A, %b %e, %H:%M", hour: "%A, %b %e, %H:%M", day: "%A, %b %e, %Y", week: "Week from %A, %b %e, %Y", month: "%B %Y", year: "%Y" }, headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>', pointFormat: '<span style="color:{series.color}">●</span> {series.name}: <b>{point.y}</b><br/>', shadow: !0, snap: At ? 25 : 10, style: { color: "#333333", cursor: "default", fontSize: "12px", padding: "8px", whiteSpace: "nowrap" } }, credits: { enabled: !0, text: "Highcharts.com", href: "http://www.highcharts.com", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#909090", fontSize: "9px" } } }).plotOptions), ne = ie.line; O(); var se = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, oe = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/, re = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, ae = function (t) { var n, s, o = []; return function (t) { t && t.stops ? s = Kt(t.stops, function (t) { return ae(t[1]) }) : (n = se.exec(t)) ? o = [i(n[1]), i(n[2]), i(n[3]), parseFloat(n[4], 10)] : (n = oe.exec(t)) ? o = [i(n[1], 16), i(n[2], 16), i(n[3], 16), 1] : (n = re.exec(t)) && (o = [i(n[1]), i(n[2]), i(n[3]), 1]) }(t), { get: function (i) { var n; return s ? ((n = e(t)).stops = [].concat(n.stops), Vt(s, function (t, e) { n.stops[e] = [n.stops[e][0], t.get(i)] })) : n = o && !isNaN(o[0]) ? "rgb" === i ? "rgb(" + o[0] + "," + o[1] + "," + o[2] + ")" : "a" === i ? o[3] : "rgba(" + o.join(",") + ")" : t, n }, brighten: function (t) { if (s) Vt(s, function (e) { e.brighten(t) }); else if (r(t) && 0 !== t) { var e; for (e = 0; e < 3; e++)o[e] += i(255 * t), o[e] < 0 && (o[e] = 0), o[e] > 255 && (o[e] = 255) } return this }, rgba: o, setOpacity: function (t) { return o[3] = t, this } } }; z.prototype = { init: function (t, e) { this.element = "span" === e ? g(e) : at.createElementNS(Lt, e), this.renderer = t }, opacity: 1, animate: function (t, i, n) { i = u(i, _, !0), ee(this), i ? (i = e(i, {}), n && (i.complete = n), te(this, t, i)) : (this.attr(t), n && n()) }, colorGradient: function (t, i, n) { var s, r, a, h, l, d, p, u, f, g, m = this.renderer, y = []; if (t.linearGradient ? r = "linearGradient" : t.radialGradient && (r = "radialGradient"), r) { for (g in a = t[r], h = m.gradients, d = t.stops, f = n.radialReference, o(a) && (t[r] = a = { x1: a[0], y1: a[1], x2: a[2], y2: a[3], gradientUnits: "userSpaceOnUse" }), "radialGradient" === r && f && !c(a.gradientUnits) && (a = e(a, { cx: f[0] - f[2] / 2 + a.cx * f[2], cy: f[1] - f[2] / 2 + a.cy * f[2], r: a.r * f[2], gradientUnits: "userSpaceOnUse" })), a) "id" !== g && y.push(g, a[g]); for (g in d) y.push(d[g]); h[y = y.join(",")] ? t = h[y].attr("id") : (a.id = t = "highcharts-" + Ot++ , h[y] = l = m.createElement(r).attr(a).add(m.defs), l.stops = [], Vt(d, function (t) { 0 === t[1].indexOf("rgba") ? (s = ae(t[1]), p = s.get("rgb"), u = s.get("a")) : (p = t[1], u = 1), t = m.createElement("stop").attr({ offset: t[0], "stop-color": p, "stop-opacity": u }).add(l), l.stops.push(t) })), n.setAttribute(i, "url(" + m.url + "#" + t + ")") } }, attr: function (t, e) { var i, n, s, o, r = this.element, a = this; if ("string" == typeof t && e !== H && (i = t, (t = {})[i] = e), "string" == typeof t) a = (this[t + "Getter"] || this._defaultGetter).call(this, t, r); else { for (i in t) n = t[i], o = !1, this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(i) && (s || (this.symbolAttr(t), s = !0), o = !0), !this.rotation || "x" !== i && "y" !== i || (this.doTransform = !0), o || (this[i + "Setter"] || this._defaultSetter).call(this, n, i, r), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(i) && this.updateShadows(i, n); this.doTransform && (this.updateTransform(), this.doTransform = !1) } return a }, updateShadows: function (t, e) { for (var i = this.shadows, n = i.length; n--;)i[n].setAttribute(t, "height" === t ? ut(e - (i[n].cutHeight || 0), 0) : "d" === t ? this.d : e) }, addClass: function (t) { var e = this.element, i = d(e, "class") || ""; return -1 === i.indexOf(t) && d(e, "class", i + " " + t), this }, symbolAttr: function (t) { var e = this; Vt("x,y,r,start,end,width,height,innerR,anchorX,anchorY".split(","), function (i) { e[i] = u(t[i], e[i]) }), e.attr({ d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e) }) }, clip: function (t) { return this.attr("clip-path", t ? "url(" + this.renderer.url + "#" + t.id + ")" : Et) }, crisp: function (t) { var e, i, n = {}, s = t.strokeWidth || this.strokeWidth || this.attr && this.attr("stroke-width") || 0; for (e in i = ct(s) % 2 / 2, t.x = dt(t.x || this.x || 0) + i, t.y = dt(t.y || this.y || 0) + i, t.width = dt((t.width || this.width || 0) - 2 * i), t.height = dt((t.height || this.height || 0) - 2 * i), t.strokeWidth = s, t) this[e] !== t[e] && (this[e] = n[e] = t[e]); return n }, css: function (e) { var n, s, o = this.styles, r = {}, a = this.element, h = ""; if (n = !o, e && e.color && (e.fill = e.color), o) for (s in e) e[s] !== o[s] && (r[s] = e[s], n = !0); if (n) { if (n = this.textWidth = e && e.width && "text" === a.nodeName.toLowerCase() && i(e.width), o && (e = t(o, r)), this.styles = e, n && (Dt || !Ct && this.renderer.forExport) && delete e.width, wt && !Ct) f(this.element, e); else { for (s in o = function (t, e) { return "-" + e.toLowerCase() }, e) h += s.replace(/([A-Z])/g, o) + ":" + e[s] + ";"; d(a, "style", h) } n && this.added && this.renderer.buildText(this) } return this }, on: function (t, e) { var i = this, n = i.element; return W && "click" === t ? (n.ontouchstart = function (t) { i.touchEventFired = Date.now(), t.preventDefault(), e.call(n, t) }, n.onclick = function (t) { (-1 === bt.indexOf("Android") || Date.now() - (i.touchEventFired || 0) > 1100) && e.call(n, t) }) : n["on" + t] = e, this }, setRadialReference: function (t) { return this.element.radialReference = t, this }, translate: function (t, e) { return this.attr({ translateX: t, translateY: e }) }, invert: function () { return this.inverted = !0, this.updateTransform(), this }, updateTransform: function () { var t = this.translateX || 0, e = this.translateY || 0, i = this.scaleX, n = this.scaleY, s = this.inverted, o = this.rotation, r = this.element; s && (t += this.attr("width"), e += this.attr("height")), t = ["translate(" + t + "," + e + ")"], s ? t.push("rotate(90) scale(-1,1)") : o && t.push("rotate(" + o + " " + (r.getAttribute("x") || 0) + " " + (r.getAttribute("y") || 0) + ")"), (c(i) || c(n)) && t.push("scale(" + u(i, 1) + " " + u(n, 1) + ")"), t.length && r.setAttribute("transform", t.join(" ")) }, toFront: function () { var t = this.element; return t.parentNode.appendChild(t), this }, align: function (t, e, i) { var s, o, r, a, h = {}; return r = (o = this.renderer).alignedObjects, t ? (this.alignOptions = t, this.alignByTranslate = e, (!i || n(i)) && (this.alignTo = s = i || "renderer", l(r, this), r.push(this), i = null)) : (t = this.alignOptions, e = this.alignByTranslate, s = this.alignTo), i = u(i, o[s], o), s = t.align, o = t.verticalAlign, r = (i.x || 0) + (t.x || 0), a = (i.y || 0) + (t.y || 0), "right" !== s && "center" !== s || (r += (i.width - (t.width || 0)) / { right: 1, center: 2 }[s]), h[e ? "translateX" : "x"] = ct(r), "bottom" !== o && "middle" !== o || (a += (i.height - (t.height || 0)) / ({ bottom: 1, middle: 2 }[o] || 1)), h[e ? "translateY" : "y"] = ct(a), this[this.placed ? "animate" : "attr"](h), this.placed = !0, this.alignAttr = h, this }, getBBox: function () { var e, i, n = this.bBox, s = this.renderer, o = this.rotation; e = this.element; var r, a = this.styles, h = o * vt; if (("" === (i = this.textStr) || Ht.test(i)) && (r = "num." + i.toString().length + (a ? "|" + a.fontSize + "|" + a.fontFamily : "")), r && (n = s.cache[r]), !n) { if (e.namespaceURI === Lt || s.forExport) { try { n = e.getBBox ? t({}, e.getBBox()) : { width: e.offsetWidth, height: e.offsetHeight } } catch (t) { } (!n || n.width < 0) && (n = { width: 0, height: 0 }) } else n = this.htmlGetBBox(); s.isSVG && (e = n.width, i = n.height, wt && a && "11px" === a.fontSize && "16.9" === i.toPrecision(3) && (n.height = i = 14), o && (n.width = gt(i * yt(h)) + gt(e * mt(h)), n.height = gt(i * mt(h)) + gt(e * yt(h)))), this.bBox = n, r && (s.cache[r] = n) } return n }, show: function (t) { return t && this.element.namespaceURI === Lt ? (this.element.removeAttribute("visibility"), this) : this.attr({ visibility: t ? "inherit" : "visible" }) }, hide: function () { return this.attr({ visibility: "hidden" }) }, fadeOut: function (t) { var e = this; e.animate({ opacity: 0 }, { duration: t || 150, complete: function () { e.hide() } }) }, add: function (t) { var e, n, s = this.renderer, o = t || s, r = o.element || s.box, a = this.element, h = this.zIndex; if (t && (this.parentGroup = t), this.parentInverted = t && t.inverted, void 0 !== this.textStr && s.buildText(this), h && (o.handleZ = !0, h = i(h)), o.handleZ) for (t = r.childNodes, e = 0; e < t.length; e++)if (o = d(s = t[e], "zIndex"), s !== a && (i(o) > h || !c(h) && c(o))) { r.insertBefore(a, s), n = !0; break } return n || r.appendChild(a), this.added = !0, this.onAdd && this.onAdd(), this }, safeRemoveChild: function (t) { var e = t.parentNode; e && e.removeChild(t) }, destroy: function () { var t, e, i = this, n = i.element || {}, s = i.shadows, o = i.renderer.isSVG && "SPAN" === n.nodeName && i.parentGroup; if (n.onclick = n.onmouseout = n.onmouseover = n.onmousemove = n.point = null, ee(i), i.clipPath && (i.clipPath = i.clipPath.destroy()), i.stops) { for (e = 0; e < i.stops.length; e++)i.stops[e] = i.stops[e].destroy(); i.stops = null } for (i.safeRemoveChild(n), s && Vt(s, function (t) { i.safeRemoveChild(t) }); o && 0 === o.div.childNodes.length;)n = o.parentGroup, i.safeRemoveChild(o.div), delete o.div, o = n; for (t in i.alignTo && l(i.renderer.alignedObjects, i), i) delete i[t]; return null }, shadow: function (t, e, i) { var n, s, o, r, a, h, l = [], c = this.element; if (t) { for (r = u(t.width, 3), a = (t.opacity || .15) / r, h = this.parentInverted ? "(-1,-1)" : "(" + u(t.offsetX, 1) + ", " + u(t.offsetY, 1) + ")", n = 1; n <= r; n++)o = 2 * r + 1 - 2 * n, d(s = c.cloneNode(0), { isShadow: "true", stroke: t.color || "black", "stroke-opacity": a * n, "stroke-width": o, transform: "translate" + h, fill: Et }), i && (d(s, "height", ut(d(s, "height") - o, 0)), s.cutHeight = o), e ? e.element.appendChild(s) : c.parentNode.insertBefore(s, c), l.push(s); this.shadows = l } return this }, xGetter: function (t) { return "circle" === this.element.nodeName && (t = { x: "cx", y: "cy" }[t] || t), this._defaultGetter(t) }, _defaultGetter: function (t) { return t = u(this[t], this.element ? this.element.getAttribute(t) : null, 0), /^[0-9\.]+$/.test(t) && (t = parseFloat(t)), t }, dSetter: function (t, e, i) { t && t.join && (t = t.join(" ")), /(NaN| {2}|^$)/.test(t) && (t = "M 0 0"), i.setAttribute(e, t), this[e] = t }, dashstyleSetter: function (t) { var e; if (t = t && t.toLowerCase()) { for (e = (t = t.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",")).length; e--;)t[e] = i(t[e]) * this.element.getAttribute("stroke-width"); t = t.join(","), this.element.setAttribute("stroke-dasharray", t) } }, alignSetter: function (t) { this.element.setAttribute("text-anchor", { left: "start", center: "middle", right: "end" }[t]) }, opacitySetter: function (t, e, i) { this[e] = t, i.setAttribute(e, t) }, "stroke-widthSetter": function (t, e, i) { 0 === t && (t = 1e-5), this.strokeWidth = t, i.setAttribute(e, t) }, titleSetter: function (t) { var e = this.element.getElementsByTagName("title")[0]; e || (e = at.createElementNS(Lt, "title"), this.element.appendChild(e)), e.textContent = t }, textSetter: function (t) { t !== this.textStr && (delete this.bBox, this.textStr = t, this.added && this.renderer.buildText(this)) }, fillSetter: function (t, e, i) { "string" == typeof t ? i.setAttribute(e, t) : t && this.colorGradient(t, e, i) }, zIndexSetter: function (t, e, i) { i.setAttribute(e, t), this[e] = t }, _defaultSetter: function (t, e, i) { i.setAttribute(e, t) } }, z.prototype.yGetter = z.prototype.xGetter, z.prototype.translateXSetter = z.prototype.translateYSetter = z.prototype.rotationSetter = z.prototype.verticalAlignSetter = z.prototype.scaleXSetter = z.prototype.scaleYSetter = function (t, e) { this[e] = t, this.doTransform = !0 }, z.prototype.strokeSetter = z.prototype.fillSetter; var he, le, ce = function () { this.init.apply(this, arguments) }; if (ce.prototype = { Element: z, init: function (t, e, i, n, s) { var o, r, a = location; o = (n = this.createElement("svg").attr({ version: "1.1" }).css(this.getStyle(n))).element, t.appendChild(o), -1 === t.innerHTML.indexOf("xmlns") && d(o, "xmlns", Lt), this.isSVG = !0, this.box = o, this.boxWrapper = n, this.alignedObjects = [], this.url = (Pt || Tt) && at.getElementsByTagName("base").length ? a.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "", this.createElement("desc").add().element.appendChild(at.createTextNode("Created with Highcharts 4.0.1")), this.defs = this.createElement("defs").add(), this.forExport = s, this.gradients = {}, this.cache = {}, this.setSize(e, i, !1), Pt && t.getBoundingClientRect && (this.subPixelFix = e = function () { f(t, { left: 0, top: 0 }), r = t.getBoundingClientRect(), f(t, { left: pt(r.left) - r.left + "px", top: pt(r.top) - r.top + "px" }) }, e(), $t(ht, "resize", e)) }, getStyle: function (e) { return this.style = t({ fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', fontSize: "12px" }, e) }, isHidden: function () { return !this.boxWrapper.getBBox().width }, destroy: function () { var t = this.defs; return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), L(this.gradients || {}), this.gradients = null, t && (this.defs = t.destroy()), this.subPixelFix && qt(ht, "resize", this.subPixelFix), this.alignedObjects = null }, createElement: function (t) { var e = new this.Element; return e.init(this, t), e }, draw: function () { }, buildText: function (t) { for (var e, n, s = t.element, o = this, r = o.forExport, a = u(t.textStr, "").toString(), h = -1 !== a.indexOf("<"), l = s.childNodes, c = d(s, "x"), p = t.styles, g = t.textWidth, m = p && p.lineHeight, y = l.length, x = function (t) { return m ? i(m) : o.fontMetrics(/(px|em)$/.test(t && t.style.fontSize) ? t.style.fontSize : p && p.fontSize || o.style.fontSize || 12).h }; y--;)s.removeChild(l[y]); h || -1 !== a.indexOf(" ") ? (e = /<.*style="([^"]+)".*>/, n = /<.*href="(http[^"]+)".*>/, g && !t.added && this.box.appendChild(s), "" === (a = h ? a.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g) : [a])[a.length - 1] && a.pop(), Vt(a, function (i, a) { var h, l = 0; i = i.replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||"); h = i.split("|||"), Vt(h, function (i) { if ("" !== i || 1 === h.length) { var u, m = {}, y = at.createElementNS(Lt, "tspan"); if (e.test(i) && d(y, "style", u = i.match(e)[1].replace(/(;| |^)color([ :])/, "$1fill$2")), n.test(i) && !r && (d(y, "onclick", 'location.href="' + i.match(n)[1] + '"'), f(y, { cursor: "pointer" })), " " !== (i = (i.replace(/<(.|\n)*?>/g, "") || " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">")) && (y.appendChild(at.createTextNode(i)), l ? m.dx = 0 : a && null !== c && (m.x = c), d(y, m), !l && a && (!Ct && r && f(y, { display: "block" }), d(y, "dy", x(y), Tt && y.offsetHeight)), s.appendChild(y), l++ , g)) { m = (i = i.replace(/([^\^])-/g, "$1- ").split(" ")).length > 1 && "nowrap" !== p.whiteSpace; for (var v, b = t._clipHeight, k = [], w = x(), S = 1; m && (i.length || k.length);)delete t.bBox, v = t.getBBox().width, !Ct && o.forExport && (v = o.measureSpanWidth(y.firstChild.data, t.styles)), v > g && 1 !== i.length ? (y.removeChild(y.firstChild), k.unshift(i.pop())) : (i = k, k = [], i.length && (b && ++S * w > b ? (i = ["..."], t.attr("title", t.textStr)) : (d(y = at.createElementNS(Lt, "tspan"), { dy: w, x: c }), u && d(y, "style", u), s.appendChild(y), v > g && (g = v)))), i.length && y.appendChild(at.createTextNode(i.join(" ").replace(/- /g, "-"))) } } }) })) : s.appendChild(at.createTextNode(a)) }, button: function (i, n, s, o, r, a, h, l, c) { var d, p, u, f, g, m, y = this.label(i, n, s, c, null, null, null, null, "button"), x = 0; r = e({ "stroke-width": 1, stroke: "#CCCCCC", fill: { linearGradient: i = { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, "#FEFEFE"], [1, "#F6F6F6"]] }, r: 2, padding: 5, style: { color: "black" } }, r); return u = r.style, delete r.style, a = e(r, { stroke: "#68A", fill: { linearGradient: i, stops: [[0, "#FFF"], [1, "#ACF"]] } }, a), f = a.style, delete a.style, h = e(r, { stroke: "#68A", fill: { linearGradient: i, stops: [[0, "#9BD"], [1, "#CDF"]] } }, h), g = h.style, delete h.style, l = e(r, { style: { color: "#CCC" } }, l), m = l.style, delete l.style, $t(y.element, wt ? "mouseover" : "mouseenter", function () { 3 !== x && y.attr(a).css(f) }), $t(y.element, wt ? "mouseout" : "mouseleave", function () { 3 !== x && (d = [r, a, h][x], p = [u, f, g][x], y.attr(d).css(p)) }), y.setState = function (t) { (y.state = x = t) ? 2 === t ? y.attr(h).css(g) : 3 === t && y.attr(l).css(m) : y.attr(r).css(u) }, y.on("click", function () { 3 !== x && o.call(y) }).attr(r).css(t({ cursor: "default" }, u)) }, crispLine: function (t, e) { return t[1] === t[4] && (t[1] = t[4] = ct(t[1]) - e % 2 / 2), t[2] === t[5] && (t[2] = t[5] = ct(t[2]) + e % 2 / 2), t }, path: function (e) { var i = { fill: Et }; return o(e) ? i.d = e : s(e) && t(i, e), this.createElement("path").attr(i) }, circle: function (t, e, i) { return t = s(t) ? t : { x: t, y: e, r: i }, (e = this.createElement("circle")).xSetter = function (t) { this.element.setAttribute("cx", t) }, e.ySetter = function (t) { this.element.setAttribute("cy", t) }, e.attr(t) }, arc: function (t, e, i, n, o, r) { return s(t) && (e = t.y, i = t.r, n = t.innerR, o = t.start, r = t.end, t = t.x), (t = this.symbol("arc", t || 0, e || 0, i || 0, i || 0, { innerR: n || 0, start: o || 0, end: r || 0 })).r = i, t }, rect: function (t, e, i, n, o, r) { o = s(t) ? t.r : o; var a = this.createElement("rect"); t = s(t) ? t : t === H ? {} : { x: t, y: e, width: ut(i, 0), height: ut(n, 0) }; return r !== H && (t.strokeWidth = r, t = a.crisp(t)), o && (t.r = o), a.rSetter = function (t) { d(this.element, { rx: t, ry: t }) }, a.attr(t) }, setSize: function (t, e, i) { var n = this.alignedObjects, s = n.length; for (this.width = t, this.height = e, this.boxWrapper[u(i, !0) ? "animate" : "attr"]({ width: t, height: e }); s--;)n[s].align() }, g: function (t) { var e = this.createElement("g"); return c(t) ? e.attr({ class: "highcharts-" + t }) : e }, image: function (e, i, n, s, o) { var r = { preserveAspectRatio: Et }; return arguments.length > 1 && t(r, { x: i, y: n, width: s, height: o }), (r = this.createElement("image").attr(r)).element.setAttributeNS ? r.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", e) : r.element.setAttribute("hc-svg-href", e), r }, symbol: function (e, i, n, s, o, r) { var a, h, l, c, d = /^url\((.*?)\)$/; return (h = (h = this.symbols[e]) && h(ct(i), ct(n), s, o, r)) ? (t(a = this.path(h), { symbolName: e, x: i, y: n, width: s, height: o }), r && t(a, r)) : d.test(e) && (c = function (t, e) { t.element && (t.attr({ width: e[0], height: e[1] }), t.alignByTranslate || t.translate(ct((s - e[0]) / 2), ct((o - e[1]) / 2))) }, l = e.match(d)[1], e = It[l], (a = this.image(l).attr({ x: i, y: n })).isImg = !0, e ? c(a, e) : (a.attr({ width: 0, height: 0 }), g("img", { onload: function () { c(a, It[l] = [this.width, this.height]) }, src: l }))), a }, symbols: { circle: function (t, e, i, n) { var s = .166 * i; return ["M", t + i / 2, e, "C", t + i + s, e, t + i + s, e + n, t + i / 2, e + n, "C", t - s, e + n, t - s, e, t + i / 2, e, "Z"] }, square: function (t, e, i, n) { return ["M", t, e, "L", t + i, e, t + i, e + n, t, e + n, "Z"] }, triangle: function (t, e, i, n) { return ["M", t + i / 2, e, "L", t + i, e + n, t, e + n, "Z"] }, "triangle-down": function (t, e, i, n) { return ["M", t, e, "L", t + i, e, t + i / 2, e + n, "Z"] }, diamond: function (t, e, i, n) { return ["M", t + i / 2, e, "L", t + i, e + n / 2, t + i / 2, e + n, t, e + n / 2, "Z"] }, arc: function (t, e, i, n, s) { var o = s.start, r = (i = s.r || i || n, s.end - .001), a = (n = s.innerR, s.open), h = mt(o), l = yt(o), c = mt(r); r = yt(r); return ["M", t + i * h, e + i * l, "A", i, i, 0, s = s.end - o < xt ? 0 : 1, 1, t + i * c, e + i * r, a ? "M" : "L", t + n * c, e + n * r, "A", n, n, 0, s, 0, t + n * h, e + n * l, a ? "" : "Z"] }, callout: function (t, e, i, n, s) { var o = ft(s && s.r || 0, i, n), r = o + 6, a = s && s.anchorX, h = s && s.anchorY; return s = ["M", (t += s = ct(s.strokeWidth || 0) % 2 / 2) + o, e += s, "L", t + i - o, e, "C", t + i, e, t + i, e, t + i, e + o, "L", t + i, e + n - o, "C", t + i, e + n, t + i, e + n, t + i - o, e + n, "L", t + o, e + n, "C", t, e + n, t, e + n, t, e + n - o, "L", t, e + o, "C", t, e, t, e, t + o, e], a && a > i && h > e + r && h < e + n - r ? s.splice(13, 3, "L", t + i, h - 6, t + i + 6, h, t + i, h + 6, t + i, e + n - o) : a && a < 0 && h > e + r && h < e + n - r ? s.splice(33, 3, "L", t, h + 6, t - 6, h, t, h - 6, t, e + o) : h && h > n && a > t + r && a < t + i - r ? s.splice(23, 3, "L", a + 6, e + n, a, e + n + 6, a - 6, e + n, t + o, e + n) : h && h < 0 && a > t + r && a < t + i - r && s.splice(3, 3, "L", a - 6, e, a, e - 6, a + 6, e, i - o, e), s } }, clipRect: function (t, e, i, n) { var s = "highcharts-" + Ot++, o = this.createElement("clipPath").attr({ id: s }).add(this.defs); return (t = this.rect(t, e, i, n, 0).add(o)).id = s, t.clipPath = o, t }, text: function (t, e, i, n) { var s = Dt || !Ct && this.forExport, o = {}; return n && !this.forExport ? this.html(t, e, i) : (o.x = Math.round(e || 0), i && (o.y = Math.round(i)), (t || 0 === t) && (o.text = t), t = this.createElement("text").attr(o), s && t.css({ position: "absolute" }), n || (t.xSetter = function (t, e, i) { var n, s, o = i.childNodes; for (s = 1; s < o.length; s++)(n = o[s]).getAttribute("x") === i.getAttribute("x") && n.setAttribute("x", t); i.setAttribute(e, t) }), t) }, fontMetrics: function (t) { t = t || this.style.fontSize; return { h: t = (t = /px/.test(t) ? i(t) : /em/.test(t) ? 12 * parseFloat(t) : 12) < 24 ? t + 4 : ct(1.2 * t), b: ct(.8 * t) } }, label: function (i, n, s, o, r, a, h, l, d) { function p() { var e, i; e = P.element.style, m = (void 0 === y || void 0 === x || T.styles.textAlign) && P.textStr && P.getBBox(), T.width = (y || m.width || 0) + 2 * L + C, T.height = (x || m.height || 0) + 2 * L, k = L + S.fontMetrics(e && e.fontSize).b, w && (g || (e = ct(-A * L), i = l ? -k : 0, T.box = g = o ? S.symbol(o, e, i, T.width, T.height, D) : S.rect(e, i, T.width, T.height, 0, D[Gt]), g.attr("fill", Et).add(T)), g.isImg || g.attr(t({ width: ct(T.width), height: ct(T.height) }, D)), D = null) } function u() { var t, e = (e = T.styles) && e.textAlign, i = C + L * (1 - A); t = l ? 0 : k, c(y) && m && ("center" === e || "right" === e) && (i += { center: .5, right: 1 }[e] * (y - m.width)), i === P.x && t === P.y || (P.attr("x", i), t !== H && P.attr("y", t)), P.x = i, P.y = t } function f(t, e) { g ? g.attr(t, e) : D[t] = e } var g, m, y, x, v, b, k, w, S = this, T = S.g(d), P = S.text("", 0, 0, h).attr({ zIndex: 1 }), A = 0, L = 3, C = 0, M = 0, D = {}; T.onAdd = function () { P.add(T), T.attr({ text: i || "", x: n, y: s }), g && c(r) && T.attr({ anchorX: r, anchorY: a }) }, T.widthSetter = function (t) { y = t }, T.heightSetter = function (t) { x = t }, T.paddingSetter = function (t) { c(t) && t !== L && (L = t, u()) }, T.paddingLeftSetter = function (t) { c(t) && t !== C && (C = t, u()) }, T.alignSetter = function (t) { A = { left: 0, center: .5, right: 1 }[t] }, T.textSetter = function (t) { t !== H && P.textSetter(t), p(), u() }, T["stroke-widthSetter"] = function (t, e) { t && (w = !0), M = t % 2 / 2, f(e, t) }, T.strokeSetter = T.fillSetter = T.rSetter = function (t, e) { "fill" === e && t && (w = !0), f(e, t) }, T.anchorXSetter = function (t, e) { r = t, f(e, t + M - v) }, T.anchorYSetter = function (t, e) { a = t, f(e, t - b) }, T.xSetter = function (t) { T.x = t, A && (t -= A * ((y || m.width) + L)), v = ct(t), T.attr("translateX", v) }, T.ySetter = function (t) { b = T.y = ct(t), T.attr("translateY", b) }; var I = T.css; return t(T, { css: function (t) { if (t) { var i = {}; t = e(t); Vt("fontSize,fontWeight,fontFamily,color,lineHeight,width,textDecoration,textShadow".split(","), function (e) { t[e] !== H && (i[e] = t[e], delete t[e]) }), P.css(i) } return I.call(T, t) }, getBBox: function () { return { width: m.width + 2 * L, height: m.height + 2 * L, x: m.x - L, y: m.y - L } }, shadow: function (t) { return g && g.shadow(t), T }, destroy: function () { qt(T.element, "mouseenter"), qt(T.element, "mouseleave"), P && (P = P.destroy()), g && (g = g.destroy()), z.prototype.destroy.call(T), T = S = p = u = f = null } }) } }, G = ce, t(z.prototype, { htmlCss: function (e) { var i = this.element; return (i = e && "SPAN" === i.tagName && e.width) && (delete e.width, this.textWidth = i, this.updateTransform()), this.styles = t(this.styles, e), f(this.element, e), this }, htmlGetBBox: function () { var t = this.element, e = this.bBox; return e || ("text" === t.nodeName && (t.style.position = "absolute"), e = this.bBox = { x: t.offsetLeft, y: t.offsetTop, width: t.offsetWidth, height: t.offsetHeight }), e }, htmlUpdateTransform: function () { if (this.added) { var t = this.renderer, e = this.element, n = this.translateX || 0, s = this.translateY || 0, o = this.x || 0, r = this.y || 0, a = this.textAlign || "left", h = { left: 0, center: .5, right: 1 }[a], l = this.shadows; if (f(e, { marginLeft: n, marginTop: s }), l && Vt(l, function (t) { f(t, { marginLeft: n + 1, marginTop: s + 1 }) }), this.inverted && Vt(e.childNodes, function (i) { t.invertChild(i, e) }), "SPAN" === e.tagName) { var d, p = this.rotation, g = i(this.textWidth), m = [p, a, e.innerHTML, this.textWidth].join(","); m !== this.cTT && (d = t.fontMetrics(e.style.fontSize).b, c(p) && this.setSpanRotation(p, h, d), (l = u(this.elemWidth, e.offsetWidth)) > g && /[ \-]/.test(e.textContent || e.innerText) && (f(e, { width: g + "px", display: "block", whiteSpace: "normal" }), l = g), this.getSpanCorrection(l, d, h, p, a)), f(e, { left: o + (this.xCorr || 0) + "px", top: r + (this.yCorr || 0) + "px" }), Tt && (d = e.offsetHeight), this.cTT = m } } else this.alignOnAdd = !0 }, setSpanRotation: function (t, e, i) { var n = {}, s = wt ? "-ms-transform" : Tt ? "-webkit-transform" : Pt ? "MozTransform" : kt ? "-o-transform" : ""; n[s] = n.transform = "rotate(" + t + "deg)", n[s + (Pt ? "Origin" : "-origin")] = n.transformOrigin = 100 * e + "% " + i + "px", f(this.element, n) }, getSpanCorrection: function (t, e, i) { this.xCorr = -t * i, this.yCorr = -e } }), t(ce.prototype, { html: function (e, i, n) { var s = this.createElement("span"), o = s.element, r = s.renderer; return s.textSetter = function (t) { t !== o.innerHTML && delete this.bBox, o.innerHTML = this.textStr = t }, s.xSetter = s.ySetter = s.alignSetter = s.rotationSetter = function (t, e) { "align" === e && (e = "textAlign"), s[e] = t, s.htmlUpdateTransform() }, s.attr({ text: e, x: ct(i), y: ct(n) }).css({ position: "absolute", whiteSpace: "nowrap", fontFamily: this.style.fontFamily, fontSize: this.style.fontSize }), s.css = s.htmlCss, r.isSVG && (s.add = function (e) { var i, n = r.box.parentNode, a = []; if (this.parentGroup = e) { if (!(i = e.div)) { for (; e;)a.push(e), e = e.parentGroup; Vt(a.reverse(), function (e) { var s; i = e.div = e.div || g(Xt, { className: d(e.element, "class") }, { position: "absolute", left: (e.translateX || 0) + "px", top: (e.translateY || 0) + "px" }, i || n), s = i.style, t(e, { translateXSetter: function (t, i) { s.left = t + "px", e[i] = t, e.doTransform = !0 }, translateYSetter: function (t, i) { s.top = t + "px", e[i] = t, e.doTransform = !0 }, visibilitySetter: function (t, e) { s[e] = t } }) }) } } else i = n; return i.appendChild(o), s.added = !0, s.alignOnAdd && s.htmlUpdateTransform(), s }), s } }), !Ct && !Dt) { Yt.VMLElement = he = { init: function (t, e) { var i = ["<", e, ' filled="f" stroked="f"'], n = ["position: ", "absolute", ";"], s = e === Xt; ("shape" === e || s) && n.push("left:0;top:0;width:1px;height:1px;"), n.push("visibility: ", s ? "hidden" : "visible"), i.push(' style="', n.join(""), '"/>'), e && (i = s || "span" === e || "img" === e ? i.join("") : t.prepVML(i), this.element = g(i)), this.renderer = t }, add: function (t) { var e = this.renderer, i = this.element, n = e.box; n = t ? t.element || t : n; return t && t.inverted && e.invertChild(i, n), n.appendChild(i), this.added = !0, this.alignOnAdd && !this.deferUpdateTransform && this.updateTransform(), this.onAdd && this.onAdd(), this }, updateTransform: z.prototype.htmlUpdateTransform, setSpanRotation: function () { var t = this.rotation, e = mt(t * vt), i = yt(t * vt); f(this.element, { filter: t ? ["progid:DXImageTransform.Microsoft.Matrix(M11=", e, ", M12=", -i, ", M21=", i, ", M22=", e, ", sizingMethod='auto expand')"].join("") : Et }) }, getSpanCorrection: function (t, e, i, n, s) { var o, r = n ? mt(n * vt) : 1, a = n ? yt(n * vt) : 0, h = u(this.elemHeight, this.element.offsetHeight); this.xCorr = r < 0 && -t, this.yCorr = a < 0 && -h, o = r * a < 0, this.xCorr += a * e * (o ? 1 - i : i), this.yCorr -= r * e * (n ? o ? i : 1 - i : 1), s && "left" !== s && (this.xCorr -= t * i * (r < 0 ? -1 : 1), n && (this.yCorr -= h * i * (a < 0 ? -1 : 1)), f(this.element, { textAlign: s })) }, pathToVML: function (t) { for (var e = t.length, i = []; e--;)r(t[e]) ? i[e] = ct(10 * t[e]) - 5 : "Z" === t[e] ? i[e] = "x" : (i[e] = t[e], !t.isArc || "wa" !== t[e] && "at" !== t[e] || (i[e + 5] === i[e + 7] && (i[e + 7] += t[e + 7] > t[e + 5] ? 1 : -1), i[e + 6] === i[e + 8] && (i[e + 8] += t[e + 8] > t[e + 6] ? 1 : -1))); return i.join(" ") || "x" }, clip: function (t) { var e, i = this; return t ? (l(e = t.members, i), e.push(i), i.destroyClip = function () { l(e, i) }, t = t.getCSS(i)) : (i.destroyClip && i.destroyClip(), t = { clip: St ? "inherit" : "rect(auto)" }), i.css(t) }, css: z.prototype.htmlCss, safeRemoveChild: function (t) { t.parentNode && C(t) }, destroy: function () { return this.destroyClip && this.destroyClip(), z.prototype.destroy.apply(this) }, on: function (t, e) { return this.element["on" + t] = function () { var t = ht.event; t.target = t.srcElement, e(t) }, this }, cutOffPath: function (t, e) { var n; return 9 !== (n = (t = t.split(/[ ,]/)).length) && 11 !== n || (t[n - 4] = t[n - 2] = i(t[n - 2]) - 10 * e), t.join(" ") }, shadow: function (t, e, n) { var s, o, r, a, h, l, c, d = [], p = this.element, f = this.renderer, m = p.style, y = p.path; if (y && "string" != typeof y.value && (y = "x"), h = y, t) { for (l = u(t.width, 3), c = (t.opacity || .15) / l, s = 1; s <= 3; s++)a = 2 * l + 1 - 2 * s, n && (h = this.cutOffPath(y.value, a + .5)), r = ['<shape isShadow="true" strokeweight="', a, '" filled="false" path="', h, '" coordsize="10 10" style="', p.style.cssText, '" />'], o = g(f.prepVML(r), null, { left: i(m.left) + u(t.offsetX, 1), top: i(m.top) + u(t.offsetY, 1) }), n && (o.cutOff = a + 1), r = ['<stroke color="', t.color || "black", '" opacity="', c * s, '"/>'], g(f.prepVML(r), null, null, o), e ? e.element.appendChild(o) : p.parentNode.insertBefore(o, p), d.push(o); this.shadows = d } return this }, updateShadows: zt, setAttr: function (t, e) { St ? this.element[t] = e : this.element.setAttribute(t, e) }, classSetter: function (t) { this.element.className = t }, dashstyleSetter: function (t, e, i) { (i.getElementsByTagName("stroke")[0] || g(this.renderer.prepVML(["<stroke/>"]), null, null, i))[e] = t || "solid", this[e] = t }, dSetter: function (t, e, i) { var n = this.shadows; t = t || []; if (this.d = t.join(" "), i.path = t = this.pathToVML(t), n) for (i = n.length; i--;)n[i].path = n[i].cutOff ? this.cutOffPath(t, n[i].cutOff) : t; this.setAttr(e, t) }, fillSetter: function (t, e, i) { var n = i.nodeName; "SPAN" === n ? i.style.color = t : "IMG" !== n && (i.filled = t !== Et, this.setAttr("fillcolor", this.renderer.color(t, i, e, this))) }, opacitySetter: zt, rotationSetter: function (t, e, i) { i = i.style, this[e] = i[e] = t, i.left = -ct(yt(t * vt) + 1) + "px", i.top = ct(mt(t * vt)) + "px" }, strokeSetter: function (t, e, i) { this.setAttr("strokecolor", this.renderer.color(t, i, e)) }, "stroke-widthSetter": function (t, e, i) { i.stroked = !!t, this[e] = t, r(t) && (t += "px"), this.setAttr("strokeweight", t) }, titleSetter: function (t, e) { this.setAttr(e, t) }, visibilitySetter: function (t, e, i) { "inherit" === t && (t = "visible"), this.shadows && Vt(this.shadows, function (i) { i.style[e] = t }), "DIV" === i.nodeName && (t = "hidden" === t ? "-999em" : 0, St || (i.style[e] = t ? "visible" : "hidden"), e = "top"), i.style[e] = t }, xSetter: function (t, e, i) { this[e] = t, "x" === e ? e = "left" : "y" === e && (e = "top"), this.updateClipping ? (this[e] = t, this.updateClipping()) : i.style[e] = t }, zIndexSetter: function (t, e, i) { i.style[e] = t } }, (he = m(z, he)).prototype.ySetter = he.prototype.widthSetter = he.prototype.heightSetter = he.prototype.xSetter; var de = { Element: he, isIE8: bt.indexOf("MSIE 8.0") > -1, init: function (e, i, n, s) { var o; if (this.alignedObjects = [], o = (s = this.createElement(Xt).css(t(this.getStyle(s), { position: "relative" }))).element, e.appendChild(s.element), this.isVML = !0, this.box = o, this.boxWrapper = s, this.cache = {}, this.setSize(i, n, !1), !at.namespaces.hcv) { at.namespaces.add("hcv", "urn:schemas-microsoft-com:vml"); try { at.createStyleSheet().cssText = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } " } catch (t) { at.styleSheets[0].cssText += "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } " } } }, isHidden: function () { return !this.box.offsetWidth }, clipRect: function (e, i, n, o) { var r = this.createElement(), a = s(e); return t(r, { members: [], left: (a ? e.x : e) + 1, top: (a ? e.y : i) + 1, width: (a ? e.width : n) - 1, height: (a ? e.height : o) - 1, getCSS: function (e) { var i = (o = e.element).nodeName, n = (e = e.inverted, this.top - ("shape" === i ? o.offsetTop : 0)), s = this.left, o = s + this.width, r = n + this.height; n = { clip: "rect(" + ct(e ? s : n) + "px," + ct(e ? r : o) + "px," + ct(e ? o : r) + "px," + ct(e ? n : s) + "px)" }; return !e && St && "DIV" === i && t(n, { width: o + "px", height: r + "px" }), n }, updateClipping: function () { Vt(r.members, function (t) { t.element && t.css(r.getCSS(t)) }) } }) }, color: function (t, e, i, n) { var s, o, r, a = this, h = /^rgba/, l = Et; if (t && t.linearGradient ? r = "gradient" : t && t.radialGradient && (r = "pattern"), r) { var c, d, p, u, f, m, y, x, v = t.linearGradient || t.radialGradient, b = "", k = (t = t.stops, []), w = function () { o = ['<fill colors="' + k.join(",") + '" opacity="', f, '" o:opacity2="', u, '" type="', r, '" ', b, 'focus="100%" method="any" />'], g(a.prepVML(o), null, null, e) }; if (p = t[0], x = t[t.length - 1], p[0] > 0 && t.unshift([0, p[1]]), x[0] < 1 && t.push([1, x[1]]), Vt(t, function (t, e) { h.test(t[1]) ? (s = ae(t[1]), c = s.get("rgb"), d = s.get("a")) : (c = t[1], d = 1), k.push(100 * t[0] + "% " + c), e ? (f = d, m = c) : (u = d, y = c) }), "fill" === i) if ("gradient" === r) i = v.x1 || v[0] || 0, t = v.y1 || v[1] || 0, p = v.x2 || v[2] || 0, v = v.y2 || v[3] || 0, b = 'angle="' + (90 - 180 * lt.atan((v - t) / (p - i)) / xt) + '"', w(); else { var S, T = 2 * (l = v.r), P = 2 * l, A = v.cx, L = v.cy, C = e.radialReference; l = function () { C && (S = n.getBBox(), A += (C[0] - S.x) / S.width - .5, L += (C[1] - S.y) / S.height - .5, T *= C[2] / S.width, P *= C[2] / S.height), b = 'src="' + N.global.VMLRadialGradientURL + '" size="' + T + "," + P + '" origin="0.5,0.5" position="' + A + "," + L + '" color2="' + y + '" ', w() }; n.added ? l() : n.onAdd = l, l = m } else l = c } else h.test(t) && "IMG" !== e.tagName ? (s = ae(t), o = ["<", i, ' opacity="', s.get("a"), '"/>'], g(this.prepVML(o), null, null, e), l = s.get("rgb")) : ((l = e.getElementsByTagName(i)).length && (l[0].opacity = 1, l[0].type = "solid"), l = t); return l }, prepVML: function (t) { var e = this.isIE8; t = t.join(""); return e ? t = -1 === (t = t.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />')).indexOf('style="') ? t.replace("/>", ' style="display:inline-block;behavior:url(#default#VML);" />') : t.replace('style="', 'style="display:inline-block;behavior:url(#default#VML);') : t = t.replace("<", "<hcv:"), t }, text: ce.prototype.html, path: function (e) { var i = { coordsize: "10 10" }; return o(e) ? i.d = e : s(e) && t(i, e), this.createElement("shape").attr(i) }, circle: function (t, e, i) { var n = this.symbol("circle"); return s(t) && (i = t.r, e = t.y, t = t.x), n.isCircle = !0, n.r = i, n.attr({ x: t, y: e }) }, g: function (t) { var e; return t && (e = { className: "highcharts-" + t, class: "highcharts-" + t }), this.createElement(Xt).attr(e) }, image: function (t, e, i, n, s) { var o = this.createElement("img").attr({ src: t }); return arguments.length > 1 && o.attr({ x: e, y: i, width: n, height: s }), o }, createElement: function (t) { return "rect" === t ? this.symbol(t) : ce.prototype.createElement.call(this, t) }, invertChild: function (t, e) { var n = this, s = e.style, o = "IMG" === t.tagName && t.style; f(t, { flip: "x", left: i(s.width) - (o ? i(o.top) : 1), top: i(s.height) - (o ? i(o.left) : 1), rotation: -90 }), Vt(t.childNodes, function (e) { n.invertChild(e, t) }) }, symbols: { arc: function (t, e, i, n, s) { var o = s.start, r = s.end, a = s.r || i || n, h = (i = s.innerR, n = mt(o), yt(o)), l = mt(r), c = yt(r); return r - o == 0 ? ["x"] : (o = ["wa", t - a, e - a, t + a, e + a, t + a * n, e + a * h, t + a * l, e + a * c], s.open && !i && o.push("e", "M", t, e), o.push("at", t - i, e - i, t + i, e + i, t + i * l, e + i * c, t + i * n, e + i * h, "x", "e"), o.isArc = !0, o) }, circle: function (t, e, i, n, s) { return s && (i = n = 2 * s.r), s && s.isCircle && (t -= i / 2, e -= n / 2), ["wa", t, e, t + i, e + n, t + i, e + n / 2, t + i, e + n / 2, "e"] }, rect: function (t, e, i, n, s) { return ce.prototype.symbols[c(s) && s.r ? "callout" : "square"].call(0, t, e, i, n, s) } } }; Yt.VMLRenderer = he = function () { this.init.apply(this, arguments) }, he.prototype = e(ce.prototype, de), G = he } ce.prototype.measureSpanWidth = function (t, e) { var i, n = at.createElement("span"); return i = at.createTextNode(t), n.appendChild(i), f(n, e), this.box.appendChild(n), i = n.offsetWidth, C(n), i }, Dt && (Yt.CanVGRenderer = he = function () { Lt = "http://www.w3.org/1999/xhtml" }, he.prototype.symbols = {}, le = function () { function t() { var t, i = e.length; for (t = 0; t < i; t++)e[t](); e = [] } var e = []; return { push: function (i, n) { 0 === e.length && _t(n, t), e.push(i) } } }(), G = he), B.prototype = { addLabel: function () { var e, i = this.axis, n = i.options, s = i.chart, o = i.horiz, a = i.categories, l = i.names, d = this.pos, p = n.labels, f = i.tickPositions, g = (o = o && a && !p.step && !p.staggerLines && !p.rotation && s.plotWidth / f.length || !o && (s.margin[3] || .33 * s.chartWidth), d === f[0]), m = d === f[f.length - 1], y = (l = a ? u(a[d], l[d], d) : d, a = this.label, f.info); i.isDatetimeAxis && y && (e = n.dateTimeLabelFormats[y.higherRanks[d] || y.unitName]), this.isFirst = g, this.isLast = m, n = i.labelFormatter.call({ axis: i, chart: s, isFirst: g, isLast: m, dateTimeLabelFormat: e, value: i.isLog ? D(h(l)) : l }), d = t(d = o && { width: ut(1, ct(o - 2 * (p.padding || 10))) + "px" }, p.style), c(a) ? a && a.attr({ text: n }).css(d) : (e = { align: i.labelAlign }, r(p.rotation) && (e.rotation = p.rotation), o && p.ellipsis && (e._clipHeight = i.len / f.length), this.label = c(n) && p.enabled ? s.renderer.text(n, 0, 0, p.useHTML).attr(e).css(d).add(i.labelGroup) : null) }, getLabelSize: function () { var t = this.label, e = this.axis; return t ? t.getBBox()[e.horiz ? "height" : "width"] : 0 }, getLabelSides: function () { var t, e = this.label.getBBox(), i = (t = this.axis).horiz, n = t.options.labels; e = i ? e.width : e.height; return [t = i ? n.x - e * { left: 0, center: .5, right: 1 }[t.labelAlign] : 0, i ? e + t : e] }, handleOverflow: function (t, e) { var i, n, s, o = !0, r = this.axis, a = this.isFirst, h = this.isLast, l = r.horiz ? e.x : e.y, c = r.reversed, d = r.tickPositions, p = (u = this.getLabelSides())[0], u = u[1], f = this.label.line || 0; if (i = r.labelEdge, n = r.justifyLabels && (a || h), i[f] === H || l + p > i[f] ? i[f] = l + u : n || (o = !1), n) { i = (n = r.justifyToPlot) ? r.pos : 0, n = n ? i + r.len : r.chart.chartWidth; do { t += a ? 1 : -1, s = r.ticks[d[t]] } while (d[t] && (!s || s.label.line !== f)); r = s && s.label.xy && s.label.xy.x + s.getLabelSides()[a ? 0 : 1], a && !c || h && c ? l + p < i && (l = i - p, s && l + u > r && (o = !1)) : l + u > n && (l = n - u, s && l + p < r && (o = !1)), e.x = l } return o }, getPosition: function (t, e, i, n) { var s = this.axis, o = s.chart, r = n && o.oldChartHeight || o.chartHeight; return { x: t ? s.translate(e + i, null, null, n) + s.transB : s.left + s.offset + (s.opposite ? (n && o.oldChartWidth || o.chartWidth) - s.right - s.left : 0), y: t ? r - s.bottom + s.offset - (s.opposite ? s.height : 0) : r - s.translate(e + i, null, null, n) - s.transB } }, getLabelPosition: function (t, e, i, n, s, o, r, a) { var h = this.axis, l = h.transA, d = h.reversed, p = h.staggerLines, u = h.chart.renderer.fontMetrics(s.style.fontSize).b, f = s.rotation; t = t + s.x - (o && n ? o * l * (d ? -1 : 1) : 0), e = e + s.y - (o && !n ? o * l * (d ? 1 : -1) : 0); return f && 2 === h.side && (e -= u - u * mt(f * vt)), !c(s.y) && !f && (e += u - i.getBBox().height / 2), p && (i.line = r / (a || 1) % p, e += i.line * (h.labelOffset / p)), { x: t, y: e } }, getMarkPath: function (t, e, i, n, s, o) { return o.crispLine(["M", t, e, "L", t + (s ? 0 : -i), e + (s ? i : 0)], n) }, render: function (t, e, i) { var n = this.axis, s = n.options, o = n.chart.renderer, r = n.horiz, a = this.type, h = this.label, l = this.pos, c = s.labels, d = this.gridLine, p = a ? a + "Tick" : "tick", f = s[(x = a ? a + "Grid" : "grid") + "LineWidth"], g = s[x + "LineColor"], m = s[x + "LineDashStyle"], y = s[p + "Length"], x = s[p + "Width"] || 0, v = s[p + "Color"], b = s[p + "Position"], k = (p = this.mark, c.step), w = !0, S = n.tickmarkOffset, T = (P = this.getPosition(r, l, S, e)).x, P = P.y, A = r && T === n.pos + n.len || !r && P === n.pos ? -1 : 1; this.isActive = !0, f && (l = n.getPlotLinePath(l + S, f * A, e, !0), d === H && (d = { stroke: g, "stroke-width": f }, m && (d.dashstyle = m), a || (d.zIndex = 1), e && (d.opacity = 0), this.gridLine = d = f ? o.path(l).attr(d).add(n.gridGroup) : null), !e && d && l && d[this.isNew ? "attr" : "animate"]({ d: l, opacity: i })), x && y && ("inside" === b && (y = -y), n.opposite && (y = -y), a = this.getMarkPath(T, P, y, x * A, r, o), p ? p.animate({ d: a, opacity: i }) : this.mark = o.path(a).attr({ stroke: v, "stroke-width": x, opacity: i }).add(n.axisGroup)), h && !isNaN(T) && (h.xy = P = this.getLabelPosition(T, P, h, r, c, S, t, k), this.isFirst && !this.isLast && !u(s.showFirstLabel, 1) || this.isLast && !this.isFirst && !u(s.showLastLabel, 1) ? w = !1 : !n.isRadial && !c.step && !c.rotation && !e && 0 !== i && (w = this.handleOverflow(t, P)), k && t % k && (w = !1), w && !isNaN(P.y) ? (P.opacity = i, h[this.isNew ? "attr" : "animate"](P), this.isNew = !1) : h.attr("y", -9999)) }, destroy: function () { L(this, this.axis) } }, Yt.PlotLineOrBand = function (t, e) { this.axis = t, e && (this.options = e, this.id = e.id) }, Yt.PlotLineOrBand.prototype = { render: function () { var t, i = this, n = i.axis, s = n.horiz, o = (n.pointRange || 0) / 2, r = i.options, h = r.label, l = i.label, d = r.width, p = r.to, f = r.from, g = c(f) && c(p), m = r.value, y = r.dashStyle, x = i.svgElem, v = [], b = r.color, k = r.zIndex, w = r.events, S = {}, T = n.chart.renderer; if (n.isLog && (f = a(f), p = a(p), m = a(m)), d) v = n.getPlotLinePath(m, d), S = { stroke: b, "stroke-width": d }, y && (S.dashstyle = y); else { if (!g) return; f = ut(f, n.min - o), p = ft(p, n.max + o), v = n.getPlotBandPath(f, p, r), b && (S.fill = b), r.borderWidth && (S.stroke = r.borderColor, S["stroke-width"] = r.borderWidth) } if (c(k) && (S.zIndex = k), x) v ? x.animate({ d: v }, null, x.onGetPath) : (x.hide(), x.onGetPath = function () { x.show() }, l && (i.label = l = l.destroy())); else if (v && v.length && (i.svgElem = x = T.path(v).attr(S).add(), w)) for (t in o = function (t) { x.on(t, function (e) { w[t].apply(i, [e]) }) }, w) o(t); return h && c(h.text) && v && v.length && n.width > 0 && n.height > 0 ? (h = e({ align: s && g && "center", x: s ? !g && 4 : 10, verticalAlign: !s && g && "middle", y: s ? g ? 16 : 10 : g ? 6 : -4, rotation: s && !g && 90 }, h), l || (S = { align: h.textAlign || h.align, rotation: h.rotation }, c(k) && (S.zIndex = k), i.label = l = T.text(h.text, 0, 0, h.useHTML).attr(S).css(h.style).add()), n = [v[1], v[4], u(v[6], v[1])], v = [v[2], v[5], u(v[7], v[2])], s = P(n), g = P(v), l.align(h, !1, { x: s, y: g, width: A(n) - s, height: A(v) - g }), l.show()) : l && l.hide(), i }, destroy: function () { l(this.axis.plotLinesAndBands, this), delete this.axis, L(this) } }, R.prototype = { defaultOptions: { dateTimeLabelFormats: { millisecond: "%H:%M:%S.%L", second: "%H:%M:%S", minute: "%H:%M", hour: "%H:%M", day: "%e. %b", week: "%e. %b", month: "%b '%y", year: "%Y" }, endOnTick: !1, gridLineColor: "#C0C0C0", labels: Nt, lineColor: "#C0D0E0", lineWidth: 1, minPadding: .01, maxPadding: .01, minorGridLineColor: "#E0E0E0", minorGridLineWidth: 1, minorTickColor: "#A0A0A0", minorTickLength: 2, minorTickPosition: "outside", startOfWeek: 1, startOnTick: !1, tickColor: "#C0D0E0", tickLength: 10, tickmarkPlacement: "between", tickPixelInterval: 100, tickPosition: "outside", tickWidth: 1, title: { align: "middle", style: { color: "#707070" } }, type: "linear" }, defaultYAxisOptions: { endOnTick: !0, gridLineWidth: 1, tickPixelInterval: 72, showLastLabel: !0, labels: { x: -8, y: 3 }, lineWidth: 0, maxPadding: .05, minPadding: .05, startOnTick: !0, tickWidth: 0, title: { rotation: 270, text: "Values" }, stackLabels: { enabled: !1, formatter: function () { return y(this.total, -1) }, style: Nt.style } }, defaultLeftAxisOptions: { labels: { x: -15, y: null }, title: { rotation: 270 } }, defaultRightAxisOptions: { labels: { x: 15, y: null }, title: { rotation: 90 } }, defaultBottomAxisOptions: { labels: { x: 0, y: 20 }, title: { rotation: 0 } }, defaultTopAxisOptions: { labels: { x: 0, y: -15 }, title: { rotation: 0 } }, init: function (t, e) { var i = e.isX; this.horiz = t.inverted ? !i : i, this.coll = (this.isXAxis = i) ? "xAxis" : "yAxis", this.opposite = e.opposite, this.side = e.side || (this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e); var n = (o = this.options).type; this.labelFormatter = o.labels.formatter || this.defaultLabelFormatter, this.userOptions = e, this.minPixelPadding = 0, this.chart = t, this.reversed = o.reversed, this.zoomEnabled = !1 !== o.zoomEnabled, this.categories = o.categories || "category" === n, this.names = [], this.isLog = "logarithmic" === n, this.isDatetimeAxis = "datetime" === n, this.isLinked = c(o.linkedTo), this.tickmarkOffset = this.categories && "between" === o.tickmarkPlacement ? .5 : 0, this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len = 0, this.minRange = this.userMinRange = o.minRange || o.maxZoom, this.range = o.range, this.offset = o.offset || 0, this.stacks = {}, this.oldStacks = {}, this.min = this.max = null, this.crosshair = u(o.crosshair, p(t.options.tooltip.crosshairs)[i ? 0 : 1], !1); var s, o = this.options.events; for (s in -1 === jt(this, t.axes) && (i && !this.isColorAxis ? t.axes.splice(t.xAxis.length, 0, this) : t.axes.push(this), t[this.coll].push(this)), this.series = this.series || [], t.inverted && i && this.reversed === H && (this.reversed = !0), this.removePlotLine = this.removePlotBand = this.removePlotBandOrLine, o) $t(this, s, o[s]); this.isLog && (this.val2lin = a, this.lin2val = h) }, setOptions: function (t) { this.options = e(this.defaultOptions, this.isXAxis ? {} : this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], e(N[this.coll], t)) }, defaultLabelFormatter: function () { var t, e = this.axis, i = this.value, n = e.categories, s = this.dateTimeLabelFormat, o = N.lang.numericSymbols, r = o && o.length, a = e.options.labels.format; e = e.isLog ? i : e.tickInterval; if (a) t = b(a, this); else if (n) t = i; else if (s) t = F(s, i); else if (r && e >= 1e3) for (; r-- && t === H;)e >= (n = Math.pow(1e3, r + 1)) && null !== o[r] && (t = y(i / n, -1) + o[r]); return t === H && (t = gt(i) >= 1e4 ? y(i, 0) : y(i, -1, H, "")), t }, getSeriesExtremes: function () { var t = this, e = t.chart; t.hasVisibleSeries = !1, t.dataMin = t.dataMax = null, t.buildStacks && t.buildStacks(), Vt(t.series, function (i) { var n, s; !i.visible && e.options.chart.ignoreHiddenSeries || (n = i.options.threshold, t.hasVisibleSeries = !0, t.isLog && n <= 0 && (n = null), t.isXAxis ? (n = i.xData).length && (t.dataMin = ft(u(t.dataMin, n[0]), P(n)), t.dataMax = ut(u(t.dataMax, n[0]), A(n))) : (i.getExtremes(), s = i.dataMax, c(i = i.dataMin) && c(s) && (t.dataMin = ft(u(t.dataMin, i), i), t.dataMax = ut(u(t.dataMax, s), s)), c(n) && (t.dataMin >= n ? (t.dataMin = n, t.ignoreMinPadding = !0) : t.dataMax < n && (t.dataMax = n, t.ignoreMaxPadding = !0)))) }) }, translate: function (t, e, i, n, s, o) { var a = 1, h = 0, l = n ? this.oldTransA : this.transA, c = (n = n ? this.oldMin : this.min, this.minPixelPadding); s = (this.options.ordinal || this.isLog && s) && this.lin2val; return l || (l = this.transA), i && (a *= -1, h = this.len), this.reversed && (h -= (a *= -1) * (this.sector || this.len)), e ? (t = t * a + h, t = (t -= c) / l + n, s && (t = this.lin2val(t))) : (s && (t = this.val2lin(t)), "between" === o && (o = .5), t = a * (t - n) * l + h + a * c + (r(o) ? l * o * this.pointRange : 0)), t }, toPixels: function (t, e) { return this.translate(t, !1, !this.horiz, null, !0) + (e ? 0 : this.pos) }, toValue: function (t, e) { return this.translate(t - (e ? 0 : this.pos), !0, !this.horiz, null, !0) }, getPlotLinePath: function (t, e, i, n, s) { var o, r, a, h = this.chart, l = this.left, c = this.top, d = i && h.oldChartHeight || h.chartHeight, p = i && h.oldChartWidth || h.chartWidth; return o = this.transB, s = u(s, this.translate(t, null, null, i)), t = i = ct(s + o), o = r = ct(d - s - o), isNaN(s) ? a = !0 : this.horiz ? (o = c, r = d - this.bottom, (t < l || t > l + this.width) && (a = !0)) : (t = l, i = p - this.right, (o < c || o > c + this.height) && (a = !0)), a && !n ? null : h.renderer.crispLine(["M", t, o, "L", i, r], e || 1) }, getLinearTickPositions: function (t, e, i) { var n, s = D(dt(e / t) * t), o = D(pt(i / t) * t), a = []; if (e === i && r(e)) return [e]; for (e = s; e <= o && (a.push(e), (e = D(e + t)) !== n);)n = e; return a }, getMinorTickPositions: function () { var t, e = this.options, i = this.tickPositions, n = this.minorTickInterval, s = []; if (this.isLog) for (t = i.length, e = 1; e < t; e++)s = s.concat(this.getLogTickPositions(n, i[e - 1], i[e], !0)); else if (this.isDatetimeAxis && "auto" === e.minorTickInterval) (s = s.concat(this.getTimeTicks(this.normalizeTimeTickInterval(n), this.min, this.max, e.startOfWeek)))[0] < this.min && s.shift(); else for (i = this.min + (i[0] - this.min) % n; i <= this.max; i += n)s.push(i); return s }, adjustForMinRange: function () { var t, e, i, n, s, o = this.options, r = this.min, a = this.max, h = this.dataMax - this.dataMin >= this.minRange; if (this.isXAxis && this.minRange === H && !this.isLog && (c(o.min) || c(o.max) ? this.minRange = null : (Vt(this.series, function (t) { for (s = t.xData, i = t.xIncrement ? 1 : s.length - 1; i > 0; i--)n = s[i] - s[i - 1], (e === H || n < e) && (e = n) }), this.minRange = ft(5 * e, this.dataMax - this.dataMin))), a - r < this.minRange) { var l = this.minRange; t = [r - (t = (l - a + r) / 2), u(o.min, r - t)], h && (t[2] = this.dataMin), a = [(r = A(t)) + l, u(o.max, r + l)], h && (a[2] = this.dataMax), (a = P(a)) - r < l && (t[0] = a - l, t[1] = u(o.min, a - l), r = A(t)) } this.min = r, this.max = a }, setAxisTranslation: function (t) { var e, i = this, s = i.max - i.min, o = i.axisPointRange || 0, r = 0, a = 0, h = i.linkedParent, l = !!i.categories, d = i.transA; (i.isXAxis || l || o) && (h ? (r = h.minPointOffset, a = h.pointRangePadding) : Vt(i.series, function (t) { var h = l ? 1 : i.isXAxis ? t.pointRange : i.axisPointRange || 0, d = t.options.pointPlacement, p = t.closestPointRange; h > s && (h = 0), o = ut(o, h), r = ut(r, n(d) ? 0 : h / 2), a = ut(a, "on" === d ? 0 : h), !t.noSharedTooltip && c(p) && (e = c(e) ? ft(e, p) : p) }), h = i.ordinalSlope && e ? i.ordinalSlope / e : 1, i.minPointOffset = r *= h, i.pointRangePadding = a *= h, i.pointRange = ft(o, s), i.closestPointRange = e), t && (i.oldTransA = d), i.translationSlope = i.transA = d = i.len / (s + a || 1), i.transB = i.horiz ? i.left : i.bottom, i.minPixelPadding = d * r }, setTickPositions: function (t) { var e, i = this, n = i.chart, s = i.options, o = i.isLog, h = i.isDatetimeAxis, l = i.isXAxis, d = i.isLinked, p = i.options.tickPositioner, f = s.maxPadding, g = s.minPadding, m = s.tickInterval, y = s.minTickInterval, x = s.tickPixelInterval, v = i.categories; d ? (i.linkedParent = n[i.coll][s.linkedTo], n = i.linkedParent.getExtremes(), i.min = u(n.min, n.dataMin), i.max = u(n.max, n.dataMax), s.type !== i.linkedParent.options.type && M(11, 1)) : (i.min = u(i.userMin, s.min, i.dataMin), i.max = u(i.userMax, s.max, i.dataMax)), o && (!t && ft(i.min, u(i.dataMin, i.min)) <= 0 && M(10, 1), i.min = D(a(i.min)), i.max = D(a(i.max))), i.range && c(i.max) && (i.userMin = i.min = ut(i.min, i.max - i.range), i.userMax = i.max, i.range = null), i.beforePadding && i.beforePadding(), i.adjustForMinRange(), v || i.axisPointRange || i.usePercentage || d || !c(i.min) || !c(i.max) || !(n = i.max - i.min) || (c(s.min) || c(i.userMin) || !g || !(i.dataMin < 0) && i.ignoreMinPadding || (i.min -= n * g), c(s.max) || c(i.userMax) || !f || !(i.dataMax > 0) && i.ignoreMaxPadding || (i.max += n * f)), r(s.floor) && (i.min = ut(i.min, s.floor)), r(s.ceiling) && (i.max = ft(i.max, s.ceiling)), i.min === i.max || void 0 === i.min || void 0 === i.max ? i.tickInterval = 1 : d && !m && x === i.linkedParent.options.tickPixelInterval ? i.tickInterval = i.linkedParent.tickInterval : (i.tickInterval = u(m, v ? 1 : (i.max - i.min) * x / ut(i.len, x)), !c(m) && i.len < x && !this.isRadial && !this.isLog && !v && s.startOnTick && s.endOnTick && (e = !0, i.tickInterval /= 4)), l && !t && Vt(i.series, function (t) { t.processData(i.min !== i.oldMin || i.max !== i.oldMax) }), i.setAxisTranslation(!0), i.beforeSetTickPositions && i.beforeSetTickPositions(), i.postProcessTickInterval && (i.tickInterval = i.postProcessTickInterval(i.tickInterval)), i.pointRange && (i.tickInterval = ut(i.pointRange, i.tickInterval)), !m && i.tickInterval < y && (i.tickInterval = y), h || o || m || (i.tickInterval = w(i.tickInterval, null, k(i.tickInterval), s)), i.minorTickInterval = "auto" === s.minorTickInterval && i.tickInterval ? i.tickInterval / 5 : s.minorTickInterval, i.tickPositions = t = s.tickPositions ? [].concat(s.tickPositions) : p && p.apply(i, [i.min, i.max]), t || (!i.ordinalPositions && (i.max - i.min) / i.tickInterval > ut(2 * i.len, 200) && M(19, !0), t = h ? i.getTimeTicks(i.normalizeTimeTickInterval(i.tickInterval, s.units), i.min, i.max, s.startOfWeek, i.ordinalPositions, i.closestPointRange, !0) : o ? i.getLogTickPositions(i.tickInterval, i.min, i.max) : i.getLinearTickPositions(i.tickInterval, i.min, i.max), e && t.splice(1, t.length - 2), i.tickPositions = t), d || (o = t[0], h = t[t.length - 1], d = i.minPointOffset || 0, s.startOnTick ? i.min = o : i.min - d > o && t.shift(), s.endOnTick ? i.max = h : i.max + d < h && t.pop(), 1 === t.length && (s = gt(i.max) > 1e13 ? 1 : .001, i.min -= s, i.max += s)) }, setMaxTicks: function () { var t = this.chart, e = t.maxTicks || {}, i = this.tickPositions, n = this._maxTicksKey = [this.coll, this.pos, this.len].join("-"); !this.isLinked && !this.isDatetimeAxis && i && i.length > (e[n] || 0) && !1 !== this.options.alignTicks && (e[n] = i.length), t.maxTicks = e }, adjustTickAmount: function () { var t = this._maxTicksKey, e = this.tickPositions, i = this.chart.maxTicks; if (i && i[t] && !this.isDatetimeAxis && !this.categories && !this.isLinked && !1 !== this.options.alignTicks && this.min !== H) { var n = this.tickAmount, s = e.length; if (this.tickAmount = t = i[t], s < t) { for (; e.length < t;)e.push(D(e[e.length - 1] + this.tickInterval)); this.transA *= (s - 1) / (t - 1), this.max = e[e.length - 1] } c(n) && t !== n && (this.isDirty = !0) } }, setScale: function () { var t, e, i, n, s = this.stacks; if (this.oldMin = this.min, this.oldMax = this.max, this.oldAxisLength = this.len, this.setAxisSize(), n = this.len !== this.oldAxisLength, Vt(this.series, function (t) { (t.isDirtyData || t.isDirty || t.xAxis.isDirty) && (i = !0) }), n || i || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax) { if (!this.isXAxis) for (t in s) for (e in s[t]) s[t][e].total = null, s[t][e].cum = 0; this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickPositions(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = n || this.min !== this.oldMin || this.max !== this.oldMax) } else if (!this.isXAxis) for (t in this.oldStacks && (s = this.stacks = this.oldStacks), s) for (e in s[t]) s[t][e].cum = s[t][e].total; this.setMaxTicks() }, setExtremes: function (e, i, n, s, o) { var r = this, a = r.chart; n = u(n, !0), o = t(o, { min: e, max: i }); Jt(r, "setExtremes", o, function () { r.userMin = e, r.userMax = i, r.eventArgs = o, r.isDirtyExtremes = !0, n && a.redraw(s) }) }, zoom: function (t, e) { var i = this.dataMin, n = this.dataMax, s = this.options; return this.allowZoomOutside || (c(i) && t <= ft(i, u(s.min, i)) && (t = H), c(n) && e >= ut(n, u(s.max, n)) && (e = H)), this.displayBtn = t !== H || e !== H, this.setExtremes(t, e, !1, H, { trigger: "zoom" }), !0 }, setAxisSize: function () { var t = this.chart, e = (r = this.options).offsetLeft || 0, i = this.horiz, n = u(r.width, t.plotWidth - e + (r.offsetRight || 0)), s = u(r.height, t.plotHeight), o = u(r.top, t.plotTop), r = u(r.left, t.plotLeft + e); (e = /%$/).test(s) && (s = parseInt(s, 10) / 100 * t.plotHeight), e.test(o) && (o = parseInt(o, 10) / 100 * t.plotHeight + t.plotTop), this.left = r, this.top = o, this.width = n, this.height = s, this.bottom = t.chartHeight - s - o, this.right = t.chartWidth - n - r, this.len = ut(i ? n : s, 0), this.pos = i ? r : o }, getExtremes: function () { var t = this.isLog; return { min: t ? D(h(this.min)) : this.min, max: t ? D(h(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax } }, getThreshold: function (t) { var e = (i = this.isLog) ? h(this.min) : this.min, i = i ? h(this.max) : this.max; return e > t || null === t ? t = e : i < t && (t = i), this.translate(t, 0, 1, 0, 1) }, autoLabelAlign: function (t) { return (t = (u(t, 0) - 90 * this.side + 720) % 360) > 15 && t < 165 ? "right" : t > 195 && t < 345 ? "left" : "center" }, getOffset: function () { var t, e, i, n, s, o, r, a = this, h = a.chart, l = h.renderer, d = a.options, p = a.tickPositions, f = a.ticks, g = a.horiz, m = a.side, y = h.inverted ? [1, 0, 3, 2][m] : m, x = 0, v = 0, b = d.title, k = d.labels, w = 0, S = h.axisOffset, T = h.clipOffset, P = [-1, 1, 1, -1][m], A = 1, L = u(k.maxStaggerLines, 5), C = 2 === m ? l.fontMetrics(k.style.fontSize).b : 0; if (a.hasData = t = a.hasVisibleSeries || c(a.min) && c(a.max) && !!p, a.showAxis = h = t || u(d.showEmpty, !0), a.staggerLines = a.horiz && k.staggerLines, a.axisGroup || (a.gridGroup = l.g("grid").attr({ zIndex: d.gridZIndex || 1 }).add(), a.axisGroup = l.g("axis").attr({ zIndex: d.zIndex || 2 }).add(), a.labelGroup = l.g("axis-labels").attr({ zIndex: k.zIndex || 7 }).addClass("highcharts-" + a.coll.toLowerCase() + "-labels").add()), t || a.isLinked) { if (a.labelAlign = u(k.align || a.autoLabelAlign(k.rotation)), Vt(p, function (t) { f[t] ? f[t].addLabel() : f[t] = new B(a, t) }), a.horiz && !a.staggerLines && L && !k.rotation) { for (i = a.reversed ? [].concat(p).reverse() : p; A < L;) { for (t = [], n = !1, k = 0; k < i.length; k++)s = i[k], r = k % A, (o = (o = f[s].label && f[s].label.getBBox()) ? o.width : 0) && (s = a.translate(s), t[r] !== H && s < t[r] && (n = !0), t[r] = s + o); if (!n) break; A++ } A > 1 && (a.staggerLines = A) } Vt(p, function (t) { 0 !== m && 2 !== m && { 1: "left", 3: "right" }[m] !== a.labelAlign || (w = ut(f[t].getLabelSize(), w)) }), a.staggerLines && (w *= a.staggerLines, a.labelOffset = w) } else for (i in f) f[i].destroy(), delete f[i]; b && b.text && !1 !== b.enabled && (a.axisTitle || (a.axisTitle = l.text(b.text, 0, 0, b.useHTML).attr({ zIndex: 7, rotation: b.rotation || 0, align: b.textAlign || { low: "left", middle: "center", high: "right" }[b.align] }).addClass("highcharts-" + this.coll.toLowerCase() + "-title").css(b.style).add(a.axisGroup), a.axisTitle.isNew = !0), h && (x = a.axisTitle.getBBox()[g ? "height" : "width"], v = u(b.margin, g ? 5 : 10), e = b.offset), a.axisTitle[h ? "show" : "hide"]()), a.offset = P * u(d.offset, S[m]), a.axisTitleMargin = u(e, w + v + (w && P * d.labels[g ? "y" : "x"] - C)), S[m] = ut(S[m], a.axisTitleMargin + x + P * a.offset), T[y] = ut(T[y], 2 * dt(d.lineWidth / 2)) }, getLinePath: function (t) { var e = this.chart, i = this.opposite, n = this.offset, s = this.horiz, o = this.left + (i ? this.width : 0) + n; n = e.chartHeight - this.bottom - (i ? this.height : 0) + n; return i && (t *= -1), e.renderer.crispLine(["M", s ? this.left : o, s ? n : this.top, "L", s ? e.chartWidth - this.right : o, s ? n : e.chartHeight - this.bottom], t) }, getTitlePosition: function () { var t = this.horiz, e = this.left, n = this.top, s = this.len, o = this.options.title, r = t ? e : n, a = this.opposite, h = this.offset, l = i(o.style.fontSize || 12); s = { low: r + (t ? 0 : s), middle: r + s / 2, high: r + (t ? s : 0) }[o.align], e = (t ? n + this.height : e) + (t ? 1 : -1) * (a ? -1 : 1) * this.axisTitleMargin + (2 === this.side ? l : 0); return { x: t ? s : e + (a ? this.width : 0) + h + (o.x || 0), y: t ? e - (a ? this.height : 0) + h : s + (o.y || 0) } }, render: function () { var t, e, i, n = this, s = n.horiz, o = n.reversed, r = n.chart, a = r.renderer, l = n.options, d = n.isLog, p = n.isLinked, u = n.tickPositions, f = n.axisTitle, g = n.ticks, m = n.minorTicks, y = n.alternateBands, x = l.stackLabels, v = l.alternateGridColor, b = n.tickmarkOffset, k = l.lineWidth, w = r.hasRendered && c(n.oldMin) && !isNaN(n.oldMin), S = n.hasData, T = n.showAxis, P = l.labels.overflow, A = n.justifyLabels = s && !1 !== P; n.labelEdge.length = 0, n.justifyToPlot = "justify" === P, Vt([g, m, y], function (t) { for (var e in t) t[e].isActive = !1 }), (S || p) && (n.minorTickInterval && !n.categories && Vt(n.getMinorTickPositions(), function (t) { m[t] || (m[t] = new B(n, t, "minor")), w && m[t].isNew && m[t].render(null, !0), m[t].render(null, !1, 1) }), u.length && (t = u.slice(), (s && o || !s && !o) && t.reverse(), A && (t = t.slice(1).concat([t[0]])), Vt(t, function (e, i) { A && (i = i === t.length - 1 ? 0 : i + 1), (!p || e >= n.min && e <= n.max) && (g[e] || (g[e] = new B(n, e)), w && g[e].isNew && g[e].render(i, !0, .1), g[e].render(i, !1, 1)) }), b && 0 === n.min && (g[-1] || (g[-1] = new B(n, -1, null, !0)), g[-1].render(-1))), v && Vt(u, function (t, s) { s % 2 == 0 && t < n.max && (y[t] || (y[t] = new Yt.PlotLineOrBand(n)), e = t + b, i = u[s + 1] !== H ? u[s + 1] + b : n.max, y[t].options = { from: d ? h(e) : e, to: d ? h(i) : i, color: v }, y[t].render(), y[t].isActive = !0) }), n._addedPlotLB || (Vt((l.plotLines || []).concat(l.plotBands || []), function (t) { n.addPlotBandOrLine(t) }), n._addedPlotLB = !0)), Vt([g, m, y], function (t) { var e, i, n = [], s = _ ? _.duration || 500 : 0, o = function () { for (i = n.length; i--;)t[n[i]] && !t[n[i]].isActive && (t[n[i]].destroy(), delete t[n[i]]) }; for (e in t) t[e].isActive || (t[e].render(e, !1, 0), t[e].isActive = !1, n.push(e)); t !== y && r.hasRendered && s ? s && setTimeout(o, s) : o() }), k && (s = n.getLinePath(k), n.axisLine ? n.axisLine.animate({ d: s }) : n.axisLine = a.path(s).attr({ stroke: l.lineColor, "stroke-width": k, zIndex: 7 }).add(n.axisGroup), n.axisLine[T ? "show" : "hide"]()), f && T && (f[f.isNew ? "attr" : "animate"](n.getTitlePosition()), f.isNew = !1), x && x.enabled && n.renderStackTotals(), n.isDirty = !1 }, redraw: function () { var t = this.chart.pointer; t && t.reset(!0), this.render(), Vt(this.plotLinesAndBands, function (t) { t.render() }), Vt(this.series, function (t) { t.isDirty = !0 }) }, destroy: function (t) { var e, i = this, n = i.stacks, s = i.plotLinesAndBands; for (e in t || qt(i), n) L(n[e]), n[e] = null; for (Vt([i.ticks, i.minorTicks, i.alternateBands], function (t) { L(t) }), t = s.length; t--;)s[t].destroy(); Vt("stackTotalGroup,axisLine,axisTitle,axisGroup,cross,gridGroup,labelGroup".split(","), function (t) { i[t] && (i[t] = i[t].destroy()) }), this.cross && this.cross.destroy() }, drawCrosshair: function (t, e) { if (this.crosshair) if (!1 === (c(e) || !u(this.crosshair.snap, !0))) this.hideCrosshair(); else { var i, n = this.crosshair, s = n.animation; u(n.snap, !0) ? c(e) && (i = this.chart.inverted != this.horiz ? e.plotX : this.len - e.plotY) : i = this.horiz ? t.chartX - this.pos : this.len - t.chartY + this.pos, null === (i = this.isRadial ? this.getPlotLinePath(this.isXAxis ? e.x : u(e.stackY, e.y)) : this.getPlotLinePath(null, null, null, null, i)) ? this.hideCrosshair() : this.cross ? this.cross.attr({ visibility: "visible" })[s ? "animate" : "attr"]({ d: i }, s) : (s = { "stroke-width": n.width || 1, stroke: n.color || "#C0C0C0", zIndex: n.zIndex || 2 }, n.dashStyle && (s.dashstyle = n.dashStyle), this.cross = this.chart.renderer.path(i).attr(s).add()) } }, hideCrosshair: function () { this.cross && this.cross.hide() } }, t(R.prototype, { getPlotBandPath: function (t, e) { var i = this.getPlotLinePath(e), n = this.getPlotLinePath(t); return n && i ? n.push(i[4], i[5], i[1], i[2]) : n = null, n }, addPlotBand: function (t) { this.addPlotBandOrLine(t, "plotBands") }, addPlotLine: function (t) { this.addPlotBandOrLine(t, "plotLines") }, addPlotBandOrLine: function (t, e) { var i = new Yt.PlotLineOrBand(this, t).render(), n = this.userOptions; return i && (e && (n[e] = n[e] || [], n[e].push(t)), this.plotLinesAndBands.push(i)), i }, removePlotBandOrLine: function (t) { for (var e = this.plotLinesAndBands, i = this.options, n = this.userOptions, s = e.length; s--;)e[s].id === t && e[s].destroy(); Vt([i.plotLines || [], n.plotLines || [], i.plotBands || [], n.plotBands || []], function (e) { for (s = e.length; s--;)e[s].id === t && l(e, e[s]) }) } }), R.prototype.getTimeTicks = function (e, i, n, s) { var o, r = [], a = {}, h = N.global.useUTC, l = new Date(i - Z), d = e.unitRange, p = e.count; if (c(i)) { d >= V.second && (l.setMilliseconds(0), l.setSeconds(d >= V.minute ? 0 : p * dt(l.getSeconds() / p))), d >= V.minute && l[et](d >= V.hour ? 0 : p * dt(l[K]() / p)), d >= V.hour && l[it](d >= V.day ? 0 : p * dt(l[$]() / p)), d >= V.day && l[nt](d >= V.month ? 1 : p * dt(l[J]() / p)), d >= V.month && (l[st](d >= V.year ? 0 : p * dt(l[Q]() / p)), o = l[tt]()), d >= V.year && (o -= o % p, l[ot](o)), d === V.week && l[nt](l[J]() - l[q]() + u(s, 1)), i = 1, Z && (l = new Date(l.getTime() + Z)), o = l[tt](); s = l.getTime(); for (var f = l[Q](), g = l[J](), m = h ? Z : (864e5 + 6e4 * l.getTimezoneOffset()) % 864e5; s < n;)r.push(s), d === V.year ? s = U(o + i * p, 0) : d === V.month ? s = U(o, f + i * p) : h || d !== V.day && d !== V.week ? s += d * p : s = U(o, f, g + i * p * (d === V.day ? 1 : 7)), i++; r.push(s), Vt(Ut(r, function (t) { return d <= V.hour && t % V.day === m }), function (t) { a[t] = "day" }) } return r.info = t(e, { higherRanks: a, totalRange: d * p }), r }, R.prototype.normalizeTimeTickInterval = function (t, e) { var i, n = e || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], s = n[n.length - 1], o = V[s[0]], r = s[1]; for (i = 0; i < n.length && (s = n[i], o = V[s[0]], r = s[1], !(n[i + 1] && t <= (o * r[r.length - 1] + V[n[i + 1][0]]) / 2)); i++); return o === V.year && t < 5 * o && (r = [1, 2, 5]), { unitRange: o, count: n = w(t / o, r, "year" === s[0] ? ut(k(t / o), 1) : 1), unitName: s[0] } }, R.prototype.getLogTickPositions = function (t, e, i, n) { var s = this.options, o = this.len, r = []; if (n || (this._minorAutoInterval = null), t >= .5) t = ct(t), r = this.getLinearTickPositions(t, e, i); else if (t >= .08) { var l, c, d, p, f; for (o = dt(e), s = t > .3 ? [1, 2, 4] : t > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; o < i + 1 && !f; o++)for (c = s.length, l = 0; l < c && !f; l++)(d = a(h(o) * s[l])) > e && (!n || p <= i) && r.push(p), p > i && (f = !0), p = d } else e = h(e), i = h(i), t = w(t = u("auto" === (t = s[n ? "minorTickInterval" : "tickInterval"]) ? null : t, this._minorAutoInterval, (i - e) * (s.tickPixelInterval / (n ? 5 : 1)) / ((n ? o / this.tickPositions.length : o) || 1)), null, k(t)), r = Kt(this.getLinearTickPositions(t, e, i), a), n || (this._minorAutoInterval = t / 5); return n || (this.tickInterval = t), r }; var pe, ue = Yt.Tooltip = function () { this.init.apply(this, arguments) }; ue.prototype = { init: function (t, e) { var n = e.borderWidth, s = e.style, o = i(s.padding); this.chart = t, this.options = e, this.crosshairs = [], this.now = { x: 0, y: 0 }, this.isHidden = !0, this.label = t.renderer.label("", 0, 0, e.shape || "callout", null, null, e.useHTML, null, "tooltip").attr({ padding: o, fill: e.backgroundColor, "stroke-width": n, r: e.borderRadius, zIndex: 8 }).css(s).css({ padding: 0 }).add().attr({ y: -9999 }), Dt || this.label.shadow(e.shadow), this.shared = e.shared }, destroy: function () { this.label && (this.label = this.label.destroy()), clearTimeout(this.hideTimer), clearTimeout(this.tooltipTimeout) }, move: function (e, i, n, s) { var o = this, r = o.now, a = !1 !== o.options.animation && !o.isHidden, h = o.followPointer || o.len > 1; t(r, { x: a ? (2 * r.x + e) / 3 : e, y: a ? (r.y + i) / 2 : i, anchorX: h ? H : a ? (2 * r.anchorX + n) / 3 : n, anchorY: h ? H : a ? (r.anchorY + s) / 2 : s }), o.label.attr(r), a && (gt(e - r.x) > 1 || gt(i - r.y) > 1) && (clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () { o && o.move(e, i, n, s) }, 32)) }, hide: function () { var t, e = this; clearTimeout(this.hideTimer), this.isHidden || (t = this.chart.hoverPoints, this.hideTimer = setTimeout(function () { e.label.fadeOut(), e.isHidden = !0 }, u(this.options.hideDelay, 500)), t && Vt(t, function (t) { t.setState() }), this.chart.hoverPoints = null) }, getAnchor: function (t, e) { var i, n, s = this.chart, o = s.inverted, r = s.plotTop, a = 0, h = 0; return i = (t = p(t))[0].tooltipPos, this.followPointer && e && (e.chartX === H && (e = s.pointer.normalize(e)), i = [e.chartX - s.plotLeft, e.chartY - r]), i || (Vt(t, function (t) { n = t.series.yAxis, a += t.plotX, h += (t.plotLow ? (t.plotLow + t.plotHigh) / 2 : t.plotY) + (!o && n ? n.top - r : 0) }), a /= t.length, h /= t.length, i = [o ? s.plotWidth - h : a, this.shared && !o && t.length > 1 && e ? e.chartY - r : o ? s.plotHeight - a : h]), Kt(i, ct) }, getPosition: function (t, e, i) { var n, s = this.chart, o = this.distance, r = {}, a = ["y", s.chartHeight, e, i.plotY + s.plotTop], h = ["x", s.chartWidth, t, i.plotX + s.plotLeft], l = i.ttBelow || s.inverted && !i.negative || !s.inverted && i.negative, c = function (t) { var e = a; a = h, h = e, n = t }, d = function () { !1 !== function (t, e, i, n) { var s = i < n - o; e = n + o + i < e, i = n - o - i; if (n += o, l && e) r[t] = n; else if (!l && s) r[t] = i; else if (s) r[t] = i; else { if (!e) return !1; r[t] = n } }.apply(0, a) ? !1 === function (t, e, i, n) { if (n < o || n > e - o) return !1; r[t] = n < i / 2 ? 1 : n > e - i / 2 ? e - i - 2 : n - i / 2 }.apply(0, h) && !n && (c(!0), d()) : n ? r.x = r.y = 0 : (c(!0), d()) }; return (s.inverted || this.len > 1) && c(), d(), r }, defaultFormatter: function (t) { var e, i = this.points || p(this), n = i[0].series; return e = [t.tooltipHeaderFormatter(i[0])], Vt(i, function (t) { n = t.series, e.push(n.tooltipFormatter && n.tooltipFormatter(t) || t.point.tooltipFormatter(n.tooltipOptions.pointFormat)) }), e.push(t.options.footerFormat || ""), e.join("") }, refresh: function (t, e) { var i, n, s, o = this.chart, r = this.label, a = this.options, h = {}, l = []; s = a.formatter || this.defaultFormatter; h = o.hoverPoints; var c, d = this.shared; clearTimeout(this.hideTimer), this.followPointer = p(t)[0].series.tooltipOptions.followPointer, i = (n = this.getAnchor(t, e))[0], n = n[1], !d || t.series && t.series.noSharedTooltip ? h = t.getLabelConfig() : (o.hoverPoints = t, h && Vt(h, function (t) { t.setState() }), Vt(t, function (t) { t.setState("hover"), l.push(t.getLabelConfig()) }), (h = { x: t[0].category, y: t[0].y }).points = l, this.len = l.length, t = t[0]), s = s.call(h, this), h = t.series, this.distance = u(h.tooltipOptions.distance, 16), !1 === s ? this.hide() : (this.isHidden && (ee(r), r.attr("opacity", 1).show()), r.attr({ text: s }), c = a.borderColor || t.color || h.color || "#606060", r.attr({ stroke: c }), this.updatePosition({ plotX: i, plotY: n, negative: t.negative, ttBelow: t.ttBelow }), this.isHidden = !1), Jt(o, "tooltipRefresh", { text: s, x: i + o.plotLeft, y: n + o.plotTop, borderColor: c }) }, updatePosition: function (t) { var e = this.chart, i = this.label; i = (this.options.positioner || this.getPosition).call(this, i.width, i.height, t); this.move(ct(i.x), ct(i.y), t.plotX + e.plotLeft, t.plotY + e.plotTop) }, tooltipHeaderFormatter: function (t) { var e, i = t.series, n = (a = i.tooltipOptions).dateTimeLabelFormats, s = a.xDateFormat, o = (h = i.xAxis) && "datetime" === h.options.type && r(t.key), a = a.headerFormat, h = h && h.closestPointRange; if (o && !s) { if (h) { for (e in V) if (V[e] >= h || V[e] <= V.day && t.key % V[e] > 0) { s = n[e]; break } } else s = n.day; s = s || n.year } return o && s && (a = a.replace("{point.key}", "{point.key:" + s + "}")), b(a, { point: t, series: i }) } }, W = at.documentElement.ontouchstart !== H; var fe = Yt.Pointer = function (t, e) { this.init(t, e) }; if (fe.prototype = { init: function (t, e) { var i, n = (o = e.chart).events, s = Dt ? "" : o.zoomType, o = t.inverted; this.options = e, this.chart = t, this.zoomX = i = /x/.test(s), this.zoomY = s = /y/.test(s), this.zoomHor = i && !o || s && o, this.zoomVert = s && !o || i && o, this.hasZoom = i || s, this.runChartClick = n && !!n.click, this.pinchDown = [], this.lastValidTouch = {}, Yt.Tooltip && e.tooltip.enabled && (t.tooltip = new ue(t, e.tooltip), this.followTouchMove = e.tooltip.followTouchMove), this.setDOMEvents() }, normalize: function (e, i) { var n, s; e = e || window.event; return (e = Qt(e)).target || (e.target = e.srcElement), s = e.touches ? e.touches.length ? e.touches.item(0) : e.changedTouches[0] : e, i || (this.chartPosition = i = Zt(this.chart.container)), s.pageX === H ? (n = ut(e.x, e.clientX - i.left), s = e.y) : (n = s.pageX - i.left, s = s.pageY - i.top), t(e, { chartX: ct(n), chartY: ct(s) }) }, getCoordinates: function (t) { var e = { xAxis: [], yAxis: [] }; return Vt(this.chart.axes, function (i) { e[i.isXAxis ? "xAxis" : "yAxis"].push({ axis: i, value: i.toValue(t[i.horiz ? "chartX" : "chartY"]) }) }), e }, getIndex: function (t) { var e = this.chart; return e.inverted ? e.plotHeight + e.plotTop - t.chartY : t.chartX - e.plotLeft }, runPointActions: function (t) { var e, i, n, s, o = this.chart, r = o.series, a = o.tooltip, h = o.hoverPoint, l = o.hoverSeries, c = o.chartWidth, d = this.getIndex(t); if (a && this.options.tooltip.shared && (!l || !l.noSharedTooltip)) { for (i = [], n = r.length, s = 0; s < n; s++)r[s].visible && !1 !== r[s].options.enableMouseTracking && !r[s].noSharedTooltip && !0 !== r[s].singularTooltips && r[s].tooltipPoints.length && (e = r[s].tooltipPoints[d]) && e.series && (e._dist = gt(d - e.clientX), c = ft(c, e._dist), i.push(e)); for (n = i.length; n--;)i[n]._dist > c && i.splice(n, 1); i.length && i[0].clientX !== this.hoverX && (a.refresh(i, t), this.hoverX = i[0].clientX) } r = l && l.tooltipOptions.followPointer, l && l.tracker && !r ? (e = l.tooltipPoints[d]) && e !== h && e.onMouseOver(t) : a && r && !a.isHidden && (l = a.getAnchor([{}], t), a.updatePosition({ plotX: l[0], plotY: l[1] })), a && !this._onDocumentMouseMove && (this._onDocumentMouseMove = function (t) { Bt[pe] && Bt[pe].pointer.onDocumentMouseMove(t) }, $t(at, "mousemove", this._onDocumentMouseMove)), Vt(o.axes, function (i) { i.drawCrosshair(t, u(e, h)) }) }, reset: function (t) { var e = this.chart, i = e.hoverSeries, n = e.hoverPoint, s = e.tooltip, o = s && s.shared ? e.hoverPoints : n; (t = t && s && o) && p(o)[0].plotX === H && (t = !1), t ? (s.refresh(o), n && n.setState(n.state, !0)) : (n && n.onMouseOut(), i && i.onMouseOut(), s && s.hide(), this._onDocumentMouseMove && (qt(at, "mousemove", this._onDocumentMouseMove), this._onDocumentMouseMove = null), Vt(e.axes, function (t) { t.hideCrosshair() }), this.hoverX = null) }, scaleGroups: function (t, e) { var i, n = this.chart; Vt(n.series, function (s) { i = t || s.getPlotBox(), s.xAxis && s.xAxis.zoomEnabled && (s.group.attr(i), s.markerGroup && (s.markerGroup.attr(i), s.markerGroup.clip(e ? n.clipRect : null)), s.dataLabelsGroup && s.dataLabelsGroup.attr(i)) }), n.clipRect.attr(e || n.clipBox) }, dragStart: function (t) { var e = this.chart; e.mouseIsDown = t.type, e.cancelClick = !1, e.mouseDownX = this.mouseDownX = t.chartX, e.mouseDownY = this.mouseDownY = t.chartY }, drag: function (t) { var e, i = this.chart, n = i.options.chart, s = t.chartX, o = t.chartY, r = this.zoomHor, a = this.zoomVert, h = i.plotLeft, l = i.plotTop, c = i.plotWidth, d = i.plotHeight, p = this.mouseDownX, u = this.mouseDownY; s < h ? s = h : s > h + c && (s = h + c), o < l ? o = l : o > l + d && (o = l + d), this.hasDragged = Math.sqrt(Math.pow(p - s, 2) + Math.pow(u - o, 2)), this.hasDragged > 10 && (e = i.isInsidePlot(p - h, u - l), i.hasCartesianSeries && (this.zoomX || this.zoomY) && e && !this.selectionMarker && (this.selectionMarker = i.renderer.rect(h, l, r ? 1 : c, a ? 1 : d, 0).attr({ fill: n.selectionMarkerFill || "rgba(69,114,167,0.25)", zIndex: 7 }).add()), this.selectionMarker && r && (s -= p, this.selectionMarker.attr({ width: gt(s), x: (s > 0 ? 0 : s) + p })), this.selectionMarker && a && (s = o - u, this.selectionMarker.attr({ height: gt(s), y: (s > 0 ? 0 : s) + u })), e && !this.selectionMarker && n.panning && i.pan(t, n.panning)) }, drop: function (e) { var i = this.chart, n = this.hasPinched; if (this.selectionMarker) { var s, o = { xAxis: [], yAxis: [], originalEvent: e.originalEvent || e }, r = (e = this.selectionMarker).attr ? e.attr("x") : e.x, a = e.attr ? e.attr("y") : e.y, h = e.attr ? e.attr("width") : e.width, l = e.attr ? e.attr("height") : e.height; (this.hasDragged || n) && (Vt(i.axes, function (t) { if (t.zoomEnabled) { var e = t.horiz, i = t.toValue(e ? r : a); e = t.toValue(e ? r + h : a + l); !isNaN(i) && !isNaN(e) && (o[t.coll].push({ axis: t, min: ft(i, e), max: ut(i, e) }), s = !0) } }), s && Jt(i, "selection", o, function (e) { i.zoom(t(e, n ? { animation: !1 } : null)) })), this.selectionMarker = this.selectionMarker.destroy(), n && this.scaleGroups() } i && (f(i.container, { cursor: i._cursor }), i.cancelClick = this.hasDragged > 10, i.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []) }, onContainerMouseDown: function (t) { (t = this.normalize(t)).preventDefault && t.preventDefault(), this.dragStart(t) }, onDocumentMouseUp: function (t) { Bt[pe] && Bt[pe].pointer.drop(t) }, onDocumentMouseMove: function (t) { var e = this.chart, i = this.chartPosition, n = e.hoverSeries; t = this.normalize(t, i); i && n && !this.inClass(t.target, "highcharts-tracker") && !e.isInsidePlot(t.chartX - e.plotLeft, t.chartY - e.plotTop) && this.reset() }, onContainerMouseLeave: function () { var t = Bt[pe]; t && (t.pointer.reset(), t.pointer.chartPosition = null) }, onContainerMouseMove: function (t) { var e = this.chart; pe = e.index, t = this.normalize(t), "mousedown" === e.mouseIsDown && this.drag(t), (this.inClass(t.target, "highcharts-tracker") || e.isInsidePlot(t.chartX - e.plotLeft, t.chartY - e.plotTop)) && !e.openMenu && this.runPointActions(t) }, inClass: function (t, e) { for (var i; t;) { if (i = d(t, "class")) { if (-1 !== i.indexOf(e)) return !0; if (-1 !== i.indexOf("highcharts-container")) return !1 } t = t.parentNode } }, onTrackerMouseOut: function (t) { var e = this.chart.hoverSeries, i = (t = t.relatedTarget || t.toElement) && t.point && t.point.series; !e || e.options.stickyTracking || this.inClass(t, "highcharts-tooltip") || i === e || e.onMouseOut() }, onContainerClick: function (e) { var i = this.chart, n = i.hoverPoint, s = i.plotLeft, o = i.plotTop; (e = this.normalize(e)).cancelBubble = !0, i.cancelClick || (n && this.inClass(e.target, "highcharts-tracker") ? (Jt(n.series, "click", t(e, { point: n })), i.hoverPoint && n.firePointEvent("click", e)) : (t(e, this.getCoordinates(e)), i.isInsidePlot(e.chartX - s, e.chartY - o) && Jt(i, "click", e))) }, setDOMEvents: function () { var t = this, e = t.chart.container; e.onmousedown = function (e) { t.onContainerMouseDown(e) }, e.onmousemove = function (e) { t.onContainerMouseMove(e) }, e.onclick = function (e) { t.onContainerClick(e) }, $t(e, "mouseleave", t.onContainerMouseLeave), 1 === Rt && $t(at, "mouseup", t.onDocumentMouseUp), W && (e.ontouchstart = function (e) { t.onContainerTouchStart(e) }, e.ontouchmove = function (e) { t.onContainerTouchMove(e) }, 1 === Rt && $t(at, "touchend", t.onDocumentTouchEnd)) }, destroy: function () { var t; for (t in qt(this.chart.container, "mouseleave", this.onContainerMouseLeave), Rt || (qt(at, "mouseup", this.onDocumentMouseUp), qt(at, "touchend", this.onDocumentTouchEnd)), clearInterval(this.tooltipTimeout), this) this[t] = null } }, t(Yt.Pointer.prototype, { pinchTranslate: function (t, e, i, n, s, o) { (this.zoomHor || this.pinchHor) && this.pinchTranslateDirection(!0, t, e, i, n, s, o), (this.zoomVert || this.pinchVert) && this.pinchTranslateDirection(!1, t, e, i, n, s, o) }, pinchTranslateDirection: function (t, e, i, n, s, o, r, a) { var h, l, c, d = this.chart, p = t ? "x" : "y", u = t ? "X" : "Y", f = "chart" + u, g = t ? "width" : "height", m = d["plot" + (t ? "Left" : "Top")], y = a || 1, x = d.inverted, v = d.bounds[t ? "h" : "v"], b = 1 === e.length, k = e[0][f], w = i[0][f], S = !b && e[1][f], T = !b && i[1][f]; (i = function () { !b && gt(k - S) > 20 && (y = a || gt(w - T) / gt(k - S)), l = (m - w) / y + k, h = d["plot" + (t ? "Width" : "Height")] / y })(), (e = l) < v.min ? (e = v.min, c = !0) : e + h > v.max && (e = v.max - h, c = !0), c ? (w -= .8 * (w - r[p][0]), b || (T -= .8 * (T - r[p][1])), i()) : r[p] = [w, T], x || (o[p] = l - m, o[g] = h), o = x ? 1 / y : y, s[g] = h, s[p] = e, n[x ? t ? "scaleY" : "scaleX" : "scale" + u] = y, n["translate" + u] = o * m + (w - o * k) }, pinch: function (e) { var i = this, n = i.chart, s = i.pinchDown, o = i.followTouchMove, r = e.touches, a = r.length, h = i.lastValidTouch, l = i.hasZoom, c = i.selectionMarker, d = {}, p = 1 === a && (i.inClass(e.target, "highcharts-tracker") && n.runTrackerClick || n.runChartClick), u = {}; (l || o) && !p && e.preventDefault(), Kt(r, function (t) { return i.normalize(t) }), "touchstart" === e.type ? (Vt(r, function (t, e) { s[e] = { chartX: t.chartX, chartY: t.chartY } }), h.x = [s[0].chartX, s[1] && s[1].chartX], h.y = [s[0].chartY, s[1] && s[1].chartY], Vt(n.axes, function (t) { if (t.zoomEnabled) { var e = n.bounds[t.horiz ? "h" : "v"], i = t.minPixelPadding, s = t.toPixels(t.dataMin), o = t.toPixels(t.dataMax), r = ft(s, o); s = ut(s, o); e.min = ft(t.pos, r - i), e.max = ut(t.pos + t.len, s + i) } })) : s.length && (c || (i.selectionMarker = c = t({ destroy: zt }, n.plotBox)), i.pinchTranslate(s, r, d, c, u, h), i.hasPinched = l, i.scaleGroups(d, u), !l && o && 1 === a && this.runPointActions(i.normalize(e))) }, onContainerTouchStart: function (t) { var e = this.chart; pe = e.index, 1 === t.touches.length ? (t = this.normalize(t), e.isInsidePlot(t.chartX - e.plotLeft, t.chartY - e.plotTop) ? (this.runPointActions(t), this.pinch(t)) : this.reset()) : 2 === t.touches.length && this.pinch(t) }, onContainerTouchMove: function (t) { (1 === t.touches.length || 2 === t.touches.length) && this.pinch(t) }, onDocumentTouchEnd: function (t) { Bt[pe] && Bt[pe].pointer.drop(t) } }), ht.PointerEvent || ht.MSPointerEvent) { var ge = {}, me = !!ht.PointerEvent, ye = function () { var t, e = []; for (t in e.item = function (t) { return this[t] }, ge) ge.hasOwnProperty(t) && e.push({ pageX: ge[t].pageX, pageY: ge[t].pageY, target: ge[t].target }); return e }, xe = function (t, e, i, n) { "touch" !== (t = t.originalEvent || t).pointerType && t.pointerType !== t.MSPOINTER_TYPE_TOUCH || !Bt[pe] || (n(t), (n = Bt[pe].pointer)[e]({ type: i, target: t.currentTarget, preventDefault: zt, touches: ye() })) }; t(fe.prototype, { onContainerPointerDown: function (t) { xe(t, "onContainerTouchStart", "touchstart", function (t) { ge[t.pointerId] = { pageX: t.pageX, pageY: t.pageY, target: t.currentTarget } }) }, onContainerPointerMove: function (t) { xe(t, "onContainerTouchMove", "touchmove", function (t) { ge[t.pointerId] = { pageX: t.pageX, pageY: t.pageY }, ge[t.pointerId].target || (ge[t.pointerId].target = t.currentTarget) }) }, onDocumentPointerUp: function (t) { xe(t, "onContainerTouchEnd", "touchend", function (t) { delete ge[t.pointerId] }) }, batchMSEvents: function (t) { t(this.chart.container, me ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown), t(this.chart.container, me ? "pointermove" : "MSPointerMove", this.onContainerPointerMove), t(at, me ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp) } }), v(fe.prototype, "init", function (t, e, i) { t.call(this, e, i), (this.hasZoom || this.followTouchMove) && f(e.container, { "-ms-touch-action": Et, "touch-action": Et }) }), v(fe.prototype, "setDOMEvents", function (t) { t.apply(this), (this.hasZoom || this.followTouchMove) && this.batchMSEvents($t) }), v(fe.prototype, "destroy", function (t) { this.batchMSEvents(qt), t.call(this) }) } var ve = Yt.Legend = function (t, e) { this.init(t, e) }; ve.prototype = { init: function (t, n) { var s = this, o = n.itemStyle, r = u(n.padding, 8), a = n.itemMarginTop || 0; this.options = n, n.enabled && (s.baseline = i(o.fontSize) + 3 + a, s.itemStyle = o, s.itemHiddenStyle = e(o, n.itemHiddenStyle), s.itemMarginTop = a, s.padding = r, s.initialItemX = r, s.initialItemY = r - 5, s.maxItemWidth = 0, s.chart = t, s.itemHeight = 0, s.lastLineHeight = 0, s.symbolWidth = u(n.symbolWidth, 16), s.pages = [], s.render(), $t(s.chart, "endResize", function () { s.positionCheckboxes() })) }, colorizeItem: function (t, e) { var i, n = this.options, s = t.legendItem, o = t.legendLine, r = t.legendSymbol, a = this.itemHiddenStyle.color, h = (n = e ? n.itemStyle.color : a, e ? t.legendColor || t.color || "#CCC" : a), l = (a = t.options && t.options.marker, { fill: h }); if (s && s.css({ fill: n, color: n }), o && o.attr({ stroke: h }), r) { if (a && r.isMarker) for (i in l.stroke = h, a = t.convertAttribs(a)) (s = a[i]) !== H && (l[i] = s); r.attr(l) } }, positionItem: function (t) { var e = (i = this.options).symbolPadding, i = !i.rtl, n = (s = t._legendItemPos)[0], s = s[1], o = t.checkbox; t.legendGroup && t.legendGroup.translate(i ? n : this.legendWidth - n - 2 * e - 4, s), o && (o.x = n, o.y = s) }, destroyItem: function (t) { var e = t.checkbox; Vt(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function (e) { t[e] && (t[e] = t[e].destroy()) }), e && C(t.checkbox) }, destroy: function () { var t = this.group, e = this.box; e && (this.box = e.destroy()), t && (this.group = t.destroy()) }, positionCheckboxes: function (t) { var e, i = this.group.alignAttr, n = this.clipHeight || this.legendHeight; i && (e = i.translateY, Vt(this.allItems, function (s) { var o, r = s.checkbox; r && (o = e + r.y + (t || 0) + 3, f(r, { left: i.translateX + s.checkboxOffset + r.x - 20 + "px", top: o + "px", display: o > e - 6 && o < e + n - 6 ? "" : Et })) })) }, renderTitle: function () { var t = this.padding, e = this.options.title, i = 0; e.text && (this.title || (this.title = this.chart.renderer.label(e.text, t - 3, t - 4, null, null, null, null, null, "legend-title").attr({ zIndex: 1 }).css(e.style).add(this.group)), i = (t = this.title.getBBox()).height, this.offsetWidth = t.width, this.contentGroup.attr({ translateY: i })), this.titleHeight = i }, renderItem: function (t) { var i = this.chart, n = i.renderer, s = this.options, o = "horizontal" === s.layout, r = this.symbolWidth, a = s.symbolPadding, h = this.itemStyle, l = this.itemHiddenStyle, c = this.padding, d = o ? u(s.itemDistance, 20) : 0, p = !s.rtl, f = s.width, g = s.itemMarginBottom || 0, m = this.itemMarginTop, y = this.initialItemX, x = t.legendItem, v = t.series && t.series.drawLegendSymbol ? t.series : t, k = v.options, w = (k = this.createCheckboxForItem && k && k.showCheckbox, s.useHTML); x || (t.legendGroup = n.g("legend-item").attr({ zIndex: 1 }).add(this.scrollGroup), v.drawLegendSymbol(this, t), t.legendItem = x = n.text(s.labelFormat ? b(s.labelFormat, t) : s.labelFormatter.call(t), p ? r + a : -a, this.baseline, w).css(e(t.visible ? h : l)).attr({ align: p ? "left" : "right", zIndex: 2 }).add(t.legendGroup), this.setItemEvents && this.setItemEvents(t, x, w, h, l), this.colorizeItem(t, t.visible), k && this.createCheckboxForItem(t)), n = x.getBBox(), r = t.checkboxOffset = s.itemWidth || t.legendItemWidth || r + a + n.width + d + (k ? 20 : 0), this.itemHeight = a = ct(t.legendItemHeight || n.height), o && this.itemX - y + r > (f || i.chartWidth - 2 * c - y - s.x) && (this.itemX = y, this.itemY += m + this.lastLineHeight + g, this.lastLineHeight = 0), this.maxItemWidth = ut(this.maxItemWidth, r), this.lastItemY = m + this.itemY + g, this.lastLineHeight = ut(a, this.lastLineHeight), t._legendItemPos = [this.itemX, this.itemY], o ? this.itemX += r : (this.itemY += m + a + g, this.lastLineHeight = a), this.offsetWidth = f || ut((o ? this.itemX - y - d : r) + c, this.offsetWidth) }, getAllItems: function () { var t = []; return Vt(this.chart.series, function (e) { var i = e.options; u(i.showInLegend, !c(i.linkedTo) && H, !0) && (t = t.concat(e.legendItems || ("point" === i.legendType ? e.data : e))) }), t }, render: function () { var e, i, n, s, o = this, r = o.chart, a = r.renderer, h = o.group, l = o.box, c = o.options, d = o.padding, p = c.borderWidth, u = c.backgroundColor; o.itemX = o.initialItemX, o.itemY = o.initialItemY, o.offsetWidth = 0, o.lastItemY = 0, h || (o.group = h = a.g("legend").attr({ zIndex: 7 }).add(), o.contentGroup = a.g().attr({ zIndex: 1 }).add(h), o.scrollGroup = a.g().add(o.contentGroup)), o.renderTitle(), T(e = o.getAllItems(), function (t, e) { return (t.options && t.options.legendIndex || 0) - (e.options && e.options.legendIndex || 0) }), c.reversed && e.reverse(), o.allItems = e, o.display = i = !!e.length, Vt(e, function (t) { o.renderItem(t) }), n = c.width || o.offsetWidth, s = o.lastItemY + o.lastLineHeight + o.titleHeight, s = o.handleOverflow(s), (p || u) && (n += d, s += d, l ? n > 0 && s > 0 && (l[l.isNew ? "attr" : "animate"](l.crisp({ width: n, height: s })), l.isNew = !1) : (o.box = l = a.rect(0, 0, n, s, c.borderRadius, p || 0).attr({ stroke: c.borderColor, "stroke-width": p || 0, fill: u || Et }).add(h).shadow(c.shadow), l.isNew = !0), l[i ? "show" : "hide"]()), o.legendWidth = n, o.legendHeight = s, Vt(e, function (t) { o.positionItem(t) }), i && h.align(t({ width: n, height: s }, c), !0, "spacingBox"), r.isResizing || this.positionCheckboxes() }, handleOverflow: function (t) { var e, i, n = this, s = this.chart, o = s.renderer, r = this.options, a = r.y, h = (a = s.spacingBox.height + ("top" === r.verticalAlign ? -a : a) - this.padding, r.maxHeight), l = this.clipRect, c = r.navigation, d = u(c.animation, !0), p = c.arrowSize || 12, f = this.nav, g = this.pages, m = this.allItems; return "horizontal" === r.layout && (a /= 2), h && (a = ft(a, h)), g.length = 0, t > a && !r.useHTML ? (this.clipHeight = e = a - 20 - this.titleHeight - this.padding, this.currentPage = u(this.currentPage, 1), this.fullHeight = t, Vt(m, function (t, n) { var s = t._legendItemPos[1], o = ct(t.legendItem.getBBox().height), r = g.length; (!r || s - g[r - 1] > e && (i || s) !== g[r - 1]) && (g.push(i || s), r++), n === m.length - 1 && s + o - g[r - 1] > e && g.push(s), s !== i && (i = s) }), l || (l = n.clipRect = o.clipRect(0, this.padding, 9999, 0), n.contentGroup.clip(l)), l.attr({ height: e }), f || (this.nav = f = o.g().attr({ zIndex: 1 }).add(this.group), this.up = o.symbol("triangle", 0, 0, p, p).on("click", function () { n.scroll(-1, d) }).add(f), this.pager = o.text("", 15, 10).css(c.style).add(f), this.down = o.symbol("triangle-down", 0, 0, p, p).on("click", function () { n.scroll(1, d) }).add(f)), n.scroll(0), t = a) : f && (l.attr({ height: s.chartHeight }), f.hide(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0), t }, scroll: function (t, e) { var i = this.pages, n = i.length, s = this.currentPage + t, o = this.clipHeight, r = (a = this.options.navigation).activeColor, a = a.inactiveColor, h = this.pager, l = this.padding; s > n && (s = n), s > 0 && (e !== H && I(e, this.chart), this.nav.attr({ translateX: l, translateY: o + this.padding + 7 + this.titleHeight, visibility: "visible" }), this.up.attr({ fill: 1 === s ? a : r }).css({ cursor: 1 === s ? "default" : "pointer" }), h.attr({ text: s + "/" + n }), this.down.attr({ x: 18 + this.pager.getBBox().width, fill: s === n ? a : r }).css({ cursor: s === n ? "default" : "pointer" }), i = -i[s - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: i }), this.currentPage = s, this.positionCheckboxes(i)) } }, Nt = Yt.LegendSymbolMixin = { drawRectangle: function (t, e) { var i = t.options.symbolHeight || 12; e.legendSymbol = this.chart.renderer.rect(0, t.baseline - 5 - i / 2, t.symbolWidth, i, t.options.symbolRadius || 0).attr({ zIndex: 3 }).add(e.legendGroup) }, drawLineMarker: function (t) { var e, i = this.options, n = i.marker; e = t.symbolWidth; var s, o = this.chart.renderer, r = this.legendGroup; t = t.baseline - ct(.3 * o.fontMetrics(t.options.itemStyle.fontSize).b); i.lineWidth && (s = { "stroke-width": i.lineWidth }, i.dashStyle && (s.dashstyle = i.dashStyle), this.legendLine = o.path(["M", 0, t, "L", e, t]).attr(s).add(r)), n && !1 !== n.enabled && (i = n.radius, this.legendSymbol = e = o.symbol(this.symbol, e / 2 - i, t - i, 2 * i, 2 * i).add(r), e.isMarker = !0) } }, (/Trident\/7\.0/.test(bt) || Pt) && v(ve.prototype, "positionItem", function (t, e) { var i = this, n = function () { e._legendItemPos && t.call(i, e) }; n(), setTimeout(n) }), X.prototype = { init: function (t, i) { var n, s = t.series; t.series = null, (n = e(N, t)).series = t.series = s, this.userOptions = t, s = n.chart, this.margin = this.splashArray("margin", s), this.spacing = this.splashArray("spacing", s); var o = s.events; this.bounds = { h: {}, v: {} }, this.callback = i, this.isResizing = 0, this.options = n, this.axes = [], this.series = [], this.hasCartesianSeries = s.showAxes; var r, a = this; if (a.index = Bt.length, Bt.push(a), Rt++ , !1 !== s.reflow && $t(a, "load", function () { a.initReflow() }), o) for (r in o) $t(a, r, o[r]); a.xAxis = [], a.yAxis = [], a.animation = !Dt && u(s.animation, !0), a.pointCount = 0, a.counters = new S, a.firstRender() }, initSeries: function (t) { var e = this.options.chart; return (e = Wt[t.type || e.type || e.defaultSeriesType]) || M(17, !0), (e = new e).init(this, t), e }, isInsidePlot: function (t, e, i) { var n = i ? e : t; t = i ? t : e; return n >= 0 && n <= this.plotWidth && t >= 0 && t <= this.plotHeight }, adjustTickAmounts: function () { !1 !== this.options.chart.alignTicks && Vt(this.axes, function (t) { t.adjustTickAmount() }), this.maxTicks = null }, redraw: function (e) { var i, n, s = this.axes, o = this.series, r = this.pointer, a = this.legend, h = this.isDirtyLegend, l = this.isDirtyBox, c = o.length, d = c, p = this.renderer, u = p.isHidden(), f = []; for (I(e, this), u && this.cloneRenderTo(), this.layOutTitles(); d--;)if ((e = o[d]).options.stacking && (i = !0, e.isDirty)) { n = !0; break } if (n) for (d = c; d--;)(e = o[d]).options.stacking && (e.isDirty = !0); Vt(o, function (t) { t.isDirty && "point" === t.options.legendType && (h = !0) }), h && a.options.enabled && (a.render(), this.isDirtyLegend = !1), i && this.getStacks(), this.hasCartesianSeries && (this.isResizing || (this.maxTicks = null, Vt(s, function (t) { t.setScale() })), this.adjustTickAmounts(), this.getMargins(), Vt(s, function (t) { t.isDirty && (l = !0) }), Vt(s, function (e) { e.isDirtyExtremes && (e.isDirtyExtremes = !1, f.push(function () { Jt(e, "afterSetExtremes", t(e.eventArgs, e.getExtremes())), delete e.eventArgs })), (l || i) && e.redraw() })), l && this.drawChartBox(), Vt(o, function (t) { t.isDirty && t.visible && (!t.isCartesian || t.xAxis) && t.redraw() }), r && r.reset(!0), p.draw(), Jt(this, "redraw"), u && this.cloneRenderTo(!0), Vt(f, function (t) { t.call() }) }, get: function (t) { var e, i, n = this.axes, s = this.series; for (e = 0; e < n.length; e++)if (n[e].options.id === t) return n[e]; for (e = 0; e < s.length; e++)if (s[e].options.id === t) return s[e]; for (e = 0; e < s.length; e++)for (i = s[e].points || [], n = 0; n < i.length; n++)if (i[n].id === t) return i[n]; return null }, getAxes: function () { var t = this, e = (i = this.options).xAxis = p(i.xAxis || {}), i = i.yAxis = p(i.yAxis || {}); Vt(e, function (t, e) { t.index = e, t.isX = !0 }), Vt(i, function (t, e) { t.index = e }), e = e.concat(i), Vt(e, function (e) { new R(t, e) }), t.adjustTickAmounts() }, getSelectedPoints: function () { var t = []; return Vt(this.series, function (e) { t = t.concat(Ut(e.points || [], function (t) { return t.selected })) }), t }, getSelectedSeries: function () { return Ut(this.series, function (t) { return t.selected }) }, getStacks: function () { var t = this; Vt(t.yAxis, function (t) { t.stacks && t.hasVisibleSeries && (t.oldStacks = t.stacks) }), Vt(t.series, function (e) { !e.options.stacking || !0 !== e.visible && !1 !== t.options.chart.ignoreHiddenSeries || (e.stackKey = e.type + u(e.options.stack, "")) }) }, setTitle: function (t, i, n) { var s, o, r = this, a = r.options; o = a.title = e(a.title, t), s = a.subtitle = e(a.subtitle, i), Vt([["title", t, o], ["subtitle", i, a = s]], function (t) { var e = t[0], i = r[e], n = t[1]; t = t[2]; i && n && (r[e] = i = i.destroy()), t && t.text && !i && (r[e] = r.renderer.text(t.text, 0, 0, t.useHTML).attr({ align: t.align, class: "highcharts-" + e, zIndex: t.zIndex || 4 }).css(t.style).add()) }), r.layOutTitles(n) }, layOutTitles: function (e) { var i = 0, n = this.title, s = this.subtitle, o = (r = this.options).title, r = r.subtitle, a = this.spacingBox.width - 44; !n || (n.css({ width: (o.width || a) + "px" }).align(t({ y: 15 }, o), !1, "spacingBox"), o.floating || o.verticalAlign) || (i = n.getBBox().height), s && (s.css({ width: (r.width || a) + "px" }).align(t({ y: i + o.margin }, r), !1, "spacingBox"), !r.floating && !r.verticalAlign && (i = pt(i + s.getBBox().height))), n = this.titleOffset !== i, this.titleOffset = i, !this.isDirtyBox && n && (this.isDirtyBox = n, this.hasRendered && u(e, !0) && this.isDirtyBox && this.redraw()) }, getChartSize: function () { var t = (e = this.options.chart).width, e = e.height, i = this.renderToClone || this.renderTo; c(t) || (this.containerWidth = Ft(i, "width")), c(e) || (this.containerHeight = Ft(i, "height")), this.chartWidth = ut(0, t || this.containerWidth || 600), this.chartHeight = ut(0, u(e, this.containerHeight > 19 ? this.containerHeight : 400)) }, cloneRenderTo: function (t) { var e = this.renderToClone, i = this.container; t ? e && (this.renderTo.appendChild(i), C(e), delete this.renderToClone) : (i && i.parentNode === this.renderTo && this.renderTo.removeChild(i), this.renderToClone = e = this.renderTo.cloneNode(0), f(e, { position: "absolute", top: "-9999px", display: "block" }), e.style.setProperty && e.style.setProperty("display", "block", "important"), at.body.appendChild(e), i && e.appendChild(i)) }, getContainer: function () { var e, s, o, r, a = this.options.chart; this.renderTo = e = a.renderTo, r = "highcharts-" + Ot++ , n(e) && (this.renderTo = e = at.getElementById(e)), e || M(13, !0), s = i(d(e, "data-highcharts-chart")), !isNaN(s) && Bt[s] && Bt[s].hasRendered && Bt[s].destroy(), d(e, "data-highcharts-chart", this.index), e.innerHTML = "", !a.skipClone && !e.offsetWidth && this.cloneRenderTo(), this.getChartSize(), s = this.chartWidth, o = this.chartHeight, this.container = e = g(Xt, { className: "highcharts-container" + (a.className ? " " + a.className : ""), id: r }, t({ position: "relative", overflow: "hidden", width: s + "px", height: o + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)" }, a.style), this.renderToClone || e), this._cursor = e.style.cursor, this.renderer = a.forExport ? new ce(e, s, o, a.style, !0) : new G(e, s, o, a.style), Dt && this.renderer.create(this, e, s, o) }, getMargins: function () { var t, e = this.spacing, i = this.legend, n = this.margin, s = this.options.legend, o = u(s.margin, 20), r = s.x, a = s.y, h = s.align, l = s.verticalAlign, d = this.titleOffset; this.resetMargins(), t = this.axisOffset, d && !c(n[0]) && (this.plotTop = ut(this.plotTop, d + this.options.title.margin + e[0])), i.display && !s.floating && ("right" === h ? c(n[1]) || (this.marginRight = ut(this.marginRight, i.legendWidth - r + o + e[1])) : "left" === h ? c(n[3]) || (this.plotLeft = ut(this.plotLeft, i.legendWidth + r + o + e[3])) : "top" === l ? c(n[0]) || (this.plotTop = ut(this.plotTop, i.legendHeight + a + o + e[0])) : "bottom" !== l || c(n[2]) || (this.marginBottom = ut(this.marginBottom, i.legendHeight - a + o + e[2]))), this.extraBottomMargin && (this.marginBottom += this.extraBottomMargin), this.extraTopMargin && (this.plotTop += this.extraTopMargin), this.hasCartesianSeries && Vt(this.axes, function (t) { t.getOffset() }), c(n[3]) || (this.plotLeft += t[3]), c(n[0]) || (this.plotTop += t[0]), c(n[2]) || (this.marginBottom += t[2]), c(n[1]) || (this.marginRight += t[1]), this.setChartSize() }, reflow: function (t) { var e = this, i = e.options.chart, n = e.renderTo, s = i.width || Ft(n, "width"), o = i.height || Ft(n, "height"); i = t ? t.target : ht, n = function () { e.container && (e.setSize(s, o, !1), e.hasUserSize = null) }; e.hasUserSize || !s || !o || i !== ht && i !== at || (s === e.containerWidth && o === e.containerHeight || (clearTimeout(e.reflowTimeout), t ? e.reflowTimeout = setTimeout(n, 100) : n()), e.containerWidth = s, e.containerHeight = o) }, initReflow: function () { var t = this, e = function (e) { t.reflow(e) }; $t(ht, "resize", e), $t(t, "destroy", function () { qt(ht, "resize", e) }) }, setSize: function (t, e, i) { var n, s, o, r = this; r.isResizing += 1, o = function () { r && Jt(r, "endResize", null, function () { r.isResizing -= 1 }) }, I(i, r), r.oldChartHeight = r.chartHeight, r.oldChartWidth = r.chartWidth, c(t) && (r.chartWidth = n = ut(0, ct(t)), r.hasUserSize = !!n), c(e) && (r.chartHeight = s = ut(0, ct(e))), (_ ? te : f)(r.container, { width: n + "px", height: s + "px" }, _), r.setChartSize(!0), r.renderer.setSize(n, s, i), r.maxTicks = null, Vt(r.axes, function (t) { t.isDirty = !0, t.setScale() }), Vt(r.series, function (t) { t.isDirty = !0 }), r.isDirtyLegend = !0, r.isDirtyBox = !0, r.layOutTitles(), r.getMargins(), r.redraw(i), r.oldChartHeight = null, Jt(r, "resize"), !1 === _ ? o() : setTimeout(o, _ && _.duration || 500) }, setChartSize: function (t) { var e, i, n, s, o = this.inverted, r = this.renderer, a = this.chartWidth, h = this.chartHeight, l = this.options.chart, c = this.spacing, d = this.clipOffset; this.plotLeft = e = ct(this.plotLeft), this.plotTop = i = ct(this.plotTop), this.plotWidth = n = ut(0, ct(a - e - this.marginRight)), this.plotHeight = s = ut(0, ct(h - i - this.marginBottom)), this.plotSizeX = o ? s : n, this.plotSizeY = o ? n : s, this.plotBorderWidth = l.plotBorderWidth || 0, this.spacingBox = r.spacingBox = { x: c[3], y: c[0], width: a - c[3] - c[1], height: h - c[0] - c[2] }, this.plotBox = r.plotBox = { x: e, y: i, width: n, height: s }, a = 2 * dt(this.plotBorderWidth / 2), o = pt(ut(a, d[3]) / 2), r = pt(ut(a, d[0]) / 2), this.clipBox = { x: o, y: r, width: dt(this.plotSizeX - ut(a, d[1]) / 2 - o), height: dt(this.plotSizeY - ut(a, d[2]) / 2 - r) }, t || Vt(this.axes, function (t) { t.setAxisSize(), t.setAxisTranslation() }) }, resetMargins: function () { var t = this.spacing, e = this.margin; this.plotTop = u(e[0], t[0]), this.marginRight = u(e[1], t[1]), this.marginBottom = u(e[2], t[2]), this.plotLeft = u(e[3], t[3]), this.axisOffset = [0, 0, 0, 0], this.clipOffset = [0, 0, 0, 0] }, drawChartBox: function () { var t, e = this.options.chart, i = this.renderer, n = this.chartWidth, s = this.chartHeight, o = this.chartBackground, r = this.plotBackground, a = this.plotBorder, h = this.plotBGImage, l = e.borderWidth || 0, c = e.backgroundColor, d = e.plotBackgroundColor, p = e.plotBackgroundImage, u = e.plotBorderWidth || 0, f = this.plotLeft, g = this.plotTop, m = this.plotWidth, y = this.plotHeight, x = this.plotBox, v = this.clipRect, b = this.clipBox; t = l + (e.shadow ? 8 : 0), (l || c) && (o ? o.animate(o.crisp({ width: n - t, height: s - t })) : (o = { fill: c || Et }, l && (o.stroke = e.borderColor, o["stroke-width"] = l), this.chartBackground = i.rect(t / 2, t / 2, n - t, s - t, e.borderRadius, l).attr(o).addClass("highcharts-background").add().shadow(e.shadow))), d && (r ? r.animate(x) : this.plotBackground = i.rect(f, g, m, y, 0).attr({ fill: d }).add().shadow(e.plotShadow)), p && (h ? h.animate(x) : this.plotBGImage = i.image(p, f, g, m, y).add()), v ? v.animate({ width: b.width, height: b.height }) : this.clipRect = i.clipRect(b), u && (a ? a.animate(a.crisp({ x: f, y: g, width: m, height: y })) : this.plotBorder = i.rect(f, g, m, y, 0, -u).attr({ stroke: e.plotBorderColor, "stroke-width": u, fill: Et, zIndex: 1 }).add()), this.isDirtyBox = !1 }, propFromSeries: function () { var t, e, i, n = this, s = n.options.chart, o = n.options.series; Vt(["inverted", "angular", "polar"], function (r) { for (t = Wt[s.type || s.defaultSeriesType], i = n[r] || s[r] || t && t.prototype[r], e = o && o.length; !i && e--;)(t = Wt[o[e].type]) && t.prototype[r] && (i = !0); n[r] = i }) }, linkSeries: function () { var t = this, e = t.series; Vt(e, function (t) { t.linkedSeries.length = 0 }), Vt(e, function (e) { var i = e.options.linkedTo; n(i) && (i = ":previous" === i ? t.series[e.index - 1] : t.get(i)) && (i.linkedSeries.push(e), e.linkedParent = i) }) }, renderSeries: function () { Vt(this.series, function (t) { t.translate(), t.setTooltipPoints && t.setTooltipPoints(), t.render() }) }, render: function () { var e, n = this, s = n.axes, o = n.renderer, r = n.options, a = r.labels, h = r.credits; n.setTitle(), n.legend = new ve(n, r.legend), n.getStacks(), Vt(s, function (t) { t.setScale() }), n.getMargins(), n.maxTicks = null, Vt(s, function (t) { t.setTickPositions(!0), t.setMaxTicks() }), n.adjustTickAmounts(), n.getMargins(), n.drawChartBox(), n.hasCartesianSeries && Vt(s, function (t) { t.render() }), n.seriesGroup || (n.seriesGroup = o.g("series-group").attr({ zIndex: 3 }).add()), n.renderSeries(), a.items && Vt(a.items, function (e) { var s = t(a.style, e.style), r = i(s.left) + n.plotLeft, h = i(s.top) + n.plotTop + 12; delete s.left, delete s.top, o.text(e.html, r, h).attr({ zIndex: 2 }).css(s).add() }), h.enabled && !n.credits && (e = h.href, n.credits = o.text(h.text, 0, 0).on("click", function () { e && (location.href = e) }).attr({ align: h.position.align, zIndex: 8 }).css(h.style).add().align(h.position)), n.hasRendered = !0 }, destroy: function () { var t, e = this, i = e.axes, n = e.series, s = e.container, o = s && s.parentNode; for (Jt(e, "destroy"), Bt[e.index] = H, Rt-- , e.renderTo.removeAttribute("data-highcharts-chart"), qt(e), t = i.length; t--;)i[t] = i[t].destroy(); for (t = n.length; t--;)n[t] = n[t].destroy(); for (t in Vt("title,subtitle,chartBackground,plotBackground,plotBGImage,plotBorder,seriesGroup,clipRect,credits,pointer,scroller,rangeSelector,legend,resetZoomButton,tooltip,renderer".split(","), function (t) { var i = e[t]; i && i.destroy && (e[t] = i.destroy()) }), s && (s.innerHTML = "", qt(s), o && C(s)), e) delete e[t] }, isReadyToRender: function () { var t = this; return !(!Ct && ht == ht.top && "complete" !== at.readyState || Dt && !ht.canvg) || (Dt ? le.push(function () { t.firstRender() }, t.options.global.canvasToolsURL) : at.attachEvent("onreadystatechange", function () { at.detachEvent("onreadystatechange", t.firstRender), "complete" === at.readyState && t.firstRender() }), !1) }, firstRender: function () { var t = this, e = t.options, i = t.callback; t.isReadyToRender() && (t.getContainer(), Jt(t, "init"), t.resetMargins(), t.setChartSize(), t.propFromSeries(), t.getAxes(), Vt(e.series || [], function (e) { t.initSeries(e) }), t.linkSeries(), Jt(t, "beforeRender"), Yt.Pointer && (t.pointer = new fe(t, e)), t.render(), t.renderer.draw(), i && i.apply(t, [t]), Vt(t.callbacks, function (e) { e.apply(t, [t]) }), t.cloneRenderTo(!0), Jt(t, "load")) }, splashArray: function (t, e) { var i = s(i = e[t]) ? i : [i, i, i, i]; return [u(e[t + "Top"], i[0]), u(e[t + "Right"], i[1]), u(e[t + "Bottom"], i[2]), u(e[t + "Left"], i[3])] } }, X.prototype.callbacks = [], he = Yt.CenteredSeriesMixin = { getCenter: function () { var t, e, n = this.options, s = this.chart, o = 2 * (n.slicedOffset || 0), r = s.plotWidth - 2 * o, a = s.plotHeight - 2 * o, h = (n = [u((s = n.center)[0], "50%"), u(s[1], "50%"), n.size || "100%", n.innerSize || 0], ft(r, a)); return Kt(n, function (n, s) { return e = /%$/.test(n), t = s < 2 || 2 === s && e, (e ? [r, a, h, h][s] * i(n) / 100 : n) + (t ? o : 0) }) } }; var be = function () { }; be.prototype = { init: function (t, e, i) { return this.series = t, this.applyOptions(e, i), this.pointAttr = {}, t.options.colorByPoint && (e = t.options.colors || t.chart.options.colors, this.color = this.color || e[t.colorCounter++], t.colorCounter === e.length) && (t.colorCounter = 0), t.chart.pointCount++ , this }, applyOptions: function (e, i) { var n = this.series, s = n.pointValKey; return t(this, e = be.prototype.optionsToObject.call(this, e)), this.options = this.options ? t(this.options, e) : e, s && (this.y = this[s]), this.x === H && n && (this.x = i === H ? n.autoIncrement() : i), this }, optionsToObject: function (t) { var e = {}, i = this.series, n = i.pointArrayMap || ["y"], s = n.length, r = 0, a = 0; if ("number" == typeof t || null === t) e[n[0]] = t; else if (o(t)) for (t.length > s && ("string" === (i = typeof t[0]) ? e.name = t[0] : "number" === i && (e.x = t[0]), r++); a < s;)e[n[a++]] = t[r++]; else "object" == typeof t && (e = t, t.dataLabels && (i._hasPointLabels = !0), t.marker && (i._hasPointMarkers = !0)); return e }, destroy: function () { var t, e = this.series.chart, i = e.hoverPoints; for (t in e.pointCount-- , i && (this.setState(), l(i, this), !i.length) && (e.hoverPoints = null), this === e.hoverPoint && this.onMouseOut(), (this.graphic || this.dataLabel) && (qt(this), this.destroyElements()), this.legendItem && e.legend.destroyItem(this), this) this[t] = null }, destroyElements: function () { for (var t, e = "graphic,dataLabel,dataLabelUpper,group,connector,shadowGroup".split(","), i = 6; i--;)this[t = e[i]] && (this[t] = this[t].destroy()) }, getLabelConfig: function () { return { x: this.category, y: this.y, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal } }, tooltipFormatter: function (t) { var e = this.series, i = e.tooltipOptions, n = u(i.valueDecimals, ""), s = i.valuePrefix || "", o = i.valueSuffix || ""; return Vt(e.pointArrayMap || ["y"], function (e) { e = "{point." + e, (s || o) && (t = t.replace(e + "}", s + e + "}" + o)), t = t.replace(e + "}", e + ":,." + n + "f}") }), b(t, { point: this, series: this.series }) }, firePointEvent: function (t, e, i) { var n = this, s = this.series.options; (s.point.events[t] || n.options && n.options.events && n.options.events[t]) && this.importEvents(), "click" === t && s.allowPointSelect && (i = function (t) { n.select(null, t.ctrlKey || t.metaKey || t.shiftKey) }), Jt(this, t, e, i) } }; var ke = function () { }; ke.prototype = { isCartesian: !0, type: "line", pointClass: be, sorted: !0, requireSorting: !0, pointAttrToOptions: { stroke: "lineColor", "stroke-width": "lineWidth", fill: "fillColor", r: "radius" }, axisTypes: ["xAxis", "yAxis"], colorCounter: 0, parallelArrays: ["x", "y"], init: function (e, i) { var n, s, o = this, r = e.series, a = function (t, e) { return u(t.options.index, t._i) - u(e.options.index, e._i) }; for (n in o.chart = e, o.options = i = o.setOptions(i), o.linkedSeries = [], o.bindAxes(), t(o, { name: i.name, state: "", pointAttr: {}, visible: !1 !== i.visible, selected: !0 === i.selected }), Dt && (i.animation = !1), s = i.events) $t(o, n, s[n]); (s && s.click || i.point && i.point.events && i.point.events.click || i.allowPointSelect) && (e.runTrackerClick = !0), o.getColor(), o.getSymbol(), Vt(o.parallelArrays, function (t) { o[t + "Data"] = [] }), o.setData(i.data, !1), o.isCartesian && (e.hasCartesianSeries = !0), r.push(o), o._i = r.length - 1, T(r, a), this.yAxis && T(this.yAxis.series, a), Vt(r, function (t, e) { t.index = e, t.name = t.name || "Series " + (e + 1) }) }, bindAxes: function () { var t, e = this, i = e.options, n = e.chart; Vt(e.axisTypes || [], function (s) { Vt(n[s], function (n) { t = n.options, (i[s] === t.index || i[s] !== H && i[s] === t.id || i[s] === H && 0 === t.index) && (n.series.push(e), e[s] = n, n.isDirty = !0) }), !e[s] && e.optionalAxis !== s && M(18, !0) }) }, updateParallelArrays: function (t, e) { var i = t.series, n = arguments; Vt(i.parallelArrays, "number" == typeof e ? function (n) { var s = "y" === n && i.toYData ? i.toYData(t) : t[n]; i[n + "Data"][e] = s } : function (t) { Array.prototype[e].apply(i[t + "Data"], Array.prototype.slice.call(n, 2)) }) }, autoIncrement: function () { var t = this.options, e = u(e = this.xIncrement, t.pointStart, 0); return this.pointInterval = u(this.pointInterval, t.pointInterval, 1), this.xIncrement = e + this.pointInterval, e }, getSegments: function () { var t, e = -1, i = [], n = this.points, s = n.length; if (s) if (this.options.connectNulls) { for (t = s; t--;)null === n[t].y && n.splice(t, 1); n.length && (i = [n]) } else Vt(n, function (t, o) { null === t.y ? (o > e + 1 && i.push(n.slice(e + 1, o)), e = o) : o === s - 1 && i.push(n.slice(e + 1, o + 1)) }); this.segments = i }, setOptions: function (t) { var i, n = (i = this.chart).options.plotOptions, s = (i = i.userOptions || {}).plotOptions || {}, o = n[this.type]; return this.userOptions = t, n = e(o, n.series, t), this.tooltipOptions = e(N.tooltip, N.plotOptions[this.type].tooltip, i.tooltip, s.series && s.series.tooltip, s[this.type] && s[this.type].tooltip, t.tooltip), null === o.marker && delete n.marker, n }, getColor: function () { var t, e = this.options, i = this.userOptions, n = this.chart.options.colors, s = this.chart.counters; (t = e.color || ie[this.type].color) || e.colorByPoint || (c(i._colorIndex) ? e = i._colorIndex : (i._colorIndex = s.color, e = s.color++), t = n[e]), this.color = t, s.wrapColor(n.length) }, getSymbol: function () { var t = this.userOptions, e = this.options.marker, i = (n = this.chart).options.symbols, n = n.counters; this.symbol = e.symbol, this.symbol || (c(t._symbolIndex) ? t = t._symbolIndex : (t._symbolIndex = n.symbol, t = n.symbol++), this.symbol = i[t]), /^url/.test(this.symbol) && (e.radius = 0), n.wrapSymbol(i.length) }, drawLegendSymbol: Nt.drawLineMarker, setData: function (t, e, i, s) { var a, h = this, l = h.points, c = l && l.length || 0, d = h.options, p = h.chart, f = null, g = h.xAxis, m = g && !!g.categories, y = h.tooltipPoints, x = d.turboThreshold, v = this.xData, b = this.yData, k = (a = h.pointArrayMap) && a.length; if (a = (t = t || []).length, e = u(e, !0), !1 === s || !a || c !== a || h.cropped || h.hasGroupedData) { if (h.xIncrement = null, h.pointRange = m ? 1 : d.pointRange, h.colorCounter = 0, Vt(this.parallelArrays, function (t) { h[t + "Data"].length = 0 }), x && a > x) { for (i = 0; null === f && i < a;)f = t[i], i++; if (r(f)) { for (m = u(d.pointStart, 0), d = u(d.pointInterval, 1), i = 0; i < a; i++)v[i] = m, b[i] = t[i], m += d; h.xIncrement = m } else if (o(f)) if (k) for (i = 0; i < a; i++)d = t[i], v[i] = d[0], b[i] = d.slice(1, k + 1); else for (i = 0; i < a; i++)d = t[i], v[i] = d[0], b[i] = d[1]; else M(12) } else for (i = 0; i < a; i++)t[i] !== H && (d = { series: h }, h.pointClass.prototype.applyOptions.apply(d, [t[i]]), h.updateParallelArrays(d, i), m && d.name) && (g.names[d.x] = d.name); for (n(b[0]) && M(14, !0), h.data = [], h.options.data = t, i = c; i--;)l[i] && l[i].destroy && l[i].destroy(); y && (y.length = 0), g && (g.minRange = g.userMinRange), h.isDirty = h.isDirtyData = p.isDirtyBox = !0, i = !1 } else Vt(t, function (t, e) { l[e].update(t, !1) }); e && p.redraw(i) }, processData: function (t) { var e, i = this.xData, n = this.yData, s = i.length; e = 0; var o, r, a, h, l = this.xAxis, c = this.options, d = c.cropThreshold, p = 0, u = this.isCartesian; if (u && !this.isDirty && !l.isDirty && !this.yAxis.isDirty && !t) return !1; for (u && this.sorted && (!d || s > d || this.forceCrop) && (a = l.min, h = l.max, i[s - 1] < a || i[0] > h ? (i = [], n = []) : (i[0] < a || i[s - 1] > h) && (i = (e = this.cropData(this.xData, this.yData, a, h)).xData, n = e.yData, e = e.start, o = !0, p = i.length)), s = i.length - 1; s >= 0; s--)t = i[s] - i[s - 1], !o && i[s] > a && i[s] < h && p++ , t > 0 && (r === H || t < r) ? r = t : t < 0 && this.requireSorting && M(15); this.cropped = o, this.cropStart = e, this.processedXData = i, this.processedYData = n, this.activePointCount = p, null === c.pointRange && (this.pointRange = r || 1), this.closestPointRange = r }, cropData: function (t, e, i, n) { var s, o = t.length, r = 0, a = o, h = u(this.cropShoulder, 1); for (s = 0; s < o; s++)if (t[s] >= i) { r = ut(0, s - h); break } for (; s < o; s++)if (t[s] > n) { a = s + h; break } return { xData: t.slice(r, a), yData: e.slice(r, a), start: r, end: a } }, generatePoints: function () { var t, e, i, n, s = this.options.data, o = this.data, r = this.processedXData, a = this.processedYData, h = this.pointClass, l = r.length, c = this.cropStart || 0, d = this.hasGroupedData, u = []; for (o || d || ((o = []).length = s.length, o = this.data = o), n = 0; n < l; n++)e = c + n, d ? u[n] = (new h).init(this, [r[n]].concat(p(a[n]))) : (o[e] ? i = o[e] : s[e] !== H && (o[e] = i = (new h).init(this, s[e], r[n])), u[n] = i); if (o && (l !== (t = o.length) || d)) for (n = 0; n < t; n++)n === c && !d && (n += l), o[n] && (o[n].destroyElements(), o[n].plotX = H); this.data = o, this.points = u }, getExtremes: function (t) { var e, i, n, s, o, r = this.yAxis, a = this.processedXData, h = [], l = 0, c = (e = this.xAxis.getExtremes()).min, d = e.max; for (e = (t = t || this.stackedYData || this.processedYData).length, o = 0; o < e; o++)if (n = a[o], i = null !== (s = t[o]) && s !== H && (!r.isLog || s.length || s > 0), n = this.getExtremesFromAll || this.cropped || (a[o + 1] || n) >= c && (a[o - 1] || n) <= d, i && n) if (i = s.length) for (; i--;)null !== s[i] && (h[l++] = s[i]); else h[l++] = s; this.dataMin = u(void 0, P(h)), this.dataMax = u(void 0, A(h)) }, translate: function () { this.processedXData || this.processData(), this.generatePoints(); for (var t = (p = this.options).stacking, e = this.xAxis, i = e.categories, n = this.yAxis, s = this.points, o = s.length, a = !!this.modifyValue, h = p.pointPlacement, l = "between" === h || r(h), d = p.threshold, p = 0; p < o; p++) { var f = s[p], g = f.x, m = f.y, y = f.low, x = t && n.stacks[(this.negStacks && m < d ? "-" : "") + this.stackKey]; n.isLog && m <= 0 && (f.y = m = null), f.plotX = e.translate(g, 0, 0, 0, 1, h, "flags" === this.type), t && this.visible && x && x[g] && (y = (m = (x = x[g]).points[this.index + "," + p])[0], m = m[1], 0 === y && (y = u(d, n.min)), n.isLog && y <= 0 && (y = null), f.total = f.stackTotal = x.total, f.percentage = x.total && f.y / x.total * 100, f.stackY = m, x.setOffset(this.pointXOffset || 0, this.barW || 0)), f.yBottom = c(y) ? n.translate(y, 0, 1, 0, 1) : null, a && (m = this.modifyValue(m, f)), f.plotY = "number" == typeof m && m !== 1 / 0 ? n.translate(m, 0, 1, 0, 1) : H, f.clientX = l ? e.translate(g, 0, 0, 0, 1) : f.plotX, f.negative = f.y < (d || 0), f.category = i && i[f.x] !== H ? i[f.x] : f.x } this.getSegments() }, animate: function (e) { var i, n = this.chart, o = n.renderer; i = this.options.animation; var r, a = this.clipBox || n.clipBox, h = n.inverted; i && !s(i) && (i = ie[this.type].animation), r = ["_sharedClip", i.duration, i.easing, a.height].join(","), e ? (e = n[r], i = n[r + "m"], e || (n[r] = e = o.clipRect(t(a, { width: 0 })), n[r + "m"] = i = o.clipRect(-99, h ? -n.plotLeft : -n.plotTop, 99, h ? n.chartWidth : n.chartHeight)), this.group.clip(e), this.markerGroup.clip(i), this.sharedClipKey = r) : ((e = n[r]) && e.animate({ width: n.plotSizeX }, i), n[r + "m"] && n[r + "m"].animate({ width: n.plotSizeX + 99 }, i), this.animate = null) }, afterAnimate: function () { var t = this.chart, e = this.sharedClipKey, i = this.group, n = this.clipBox; i && !1 !== this.options.clip && (e && n || i.clip(n ? t.renderer.clipRect(n) : t.clipRect), this.markerGroup.clip()), Jt(this, "afterAnimate"), setTimeout(function () { e && t[e] && (n || (t[e] = t[e].destroy()), t[e + "m"] && (t[e + "m"] = t[e + "m"].destroy())) }, 100) }, drawPoints: function () { var e, i, n, s, o, r, a, h, l, c = this.points, d = this.chart; i = this.options.marker; var p, f = this.pointAttr[""], g = this.markerGroup, m = u(i.enabled, this.activePointCount < .5 * this.xAxis.len / i.radius); if (!1 !== i.enabled || this._hasPointMarkers) for (s = c.length; s--;)o = c[s], i = dt(o.plotX), n = o.plotY, l = o.graphic, a = o.marker || {}, e = m && a.enabled === H || a.enabled, p = d.isInsidePlot(ct(i), n, d.inverted), e && n !== H && !isNaN(n) && null !== o.y ? (r = (e = o.pointAttr[o.selected ? "select" : ""] || f).r, h = 0 === (a = u(a.symbol, this.symbol)).indexOf("url"), l ? l[p ? "show" : "hide"](!0).animate(t({ x: i - r, y: n - r }, l.symbolName ? { width: 2 * r, height: 2 * r } : {})) : p && (r > 0 || h) && (o.graphic = d.renderer.symbol(a, i - r, n - r, 2 * r, 2 * r).attr(e).add(g))) : l && (o.graphic = l.destroy()) }, convertAttribs: function (t, e, i, n) { var s, o, r = this.pointAttrToOptions, a = {}; t = t || {}, e = e || {}, i = i || {}, n = n || {}; for (s in r) o = r[s], a[s] = u(t[o], e[s], i[s], n[s]); return a }, getAttribs: function () { var e, i = this, n = i.options, s = ie[i.type].marker ? n.marker : n, o = s.states, r = o.hover, a = i.color; e = { stroke: a, fill: a }; var h, l, d = i.points || [], p = [], u = i.pointAttrToOptions; l = i.hasPointSpecificOptions; var f, g = n.negativeColor, m = s.lineColor, y = s.fillColor; if (h = n.turboThreshold, n.marker ? (r.radius = r.radius || s.radius + 2, r.lineWidth = r.lineWidth || s.lineWidth + 1) : r.color = r.color || ae(r.color || a).brighten(r.brightness).get(), p[""] = i.convertAttribs(s, e), Vt(["hover", "select"], function (t) { p[t] = i.convertAttribs(o[t], p[""]) }), i.pointAttr = p, a = d.length, !h || a < h || l) for (; a--;) { if ((s = (h = d[a]).options && h.options.marker || h.options) && !1 === s.enabled && (s.radius = 0), h.negative && g && (h.color = h.fillColor = g), l = n.colorByPoint || h.color, h.options) for (f in u) c(s[u[f]]) && (l = !0); l ? (l = [], e = (o = (s = s || {}).states || {}).hover = o.hover || {}, n.marker || (e.color = e.color || !h.options.color && r.color || ae(h.color).brighten(e.brightness || r.brightness).get()), e = { color: h.color }, y || (e.fillColor = h.color), m || (e.lineColor = h.color), l[""] = i.convertAttribs(t(e, s), p[""]), l.hover = i.convertAttribs(o.hover, p.hover, l[""]), l.select = i.convertAttribs(o.select, p.select, l[""])) : l = p, h.pointAttr = l } }, destroy: function () { var t, e, i, n, s, o = this, r = o.chart, a = /AppleWebKit\/533/.test(bt), h = o.data || []; for (Jt(o, "destroy"), qt(o), Vt(o.axisTypes || [], function (t) { (s = o[t]) && (l(s.series, o), s.isDirty = s.forceRedraw = !0) }), o.legendItem && o.chart.legend.destroyItem(o), e = h.length; e--;)(i = h[e]) && i.destroy && i.destroy(); for (n in o.points = null, clearTimeout(o.animationTimeout), Vt("area,graph,dataLabelsGroup,group,markerGroup,tracker,graphNeg,areaNeg,posClip,negClip".split(","), function (e) { o[e] && (t = a && "group" === e ? "hide" : "destroy", o[e][t]()) }), r.hoverSeries === o && (r.hoverSeries = null), l(r.series, o), o) delete o[n] }, getSegmentPath: function (t) { var e = this, i = [], n = e.options.step; return Vt(t, function (s, o) { var r, a = s.plotX, h = s.plotY; e.getPointSpline ? i.push.apply(i, e.getPointSpline(t, s, o)) : (i.push(o ? "L" : "M"), n && o && (r = t[o - 1], "right" === n ? i.push(r.plotX, h) : "center" === n ? i.push((r.plotX + a) / 2, r.plotY, (r.plotX + a) / 2, h) : i.push(a, r.plotY)), i.push(s.plotX, s.plotY)) }), i }, getGraphPath: function () { var t, e = this, i = [], n = []; return Vt(e.segments, function (s) { t = e.getSegmentPath(s), s.length > 1 ? i = i.concat(t) : n.push(s[0]) }), e.singlePoints = n, e.graphPath = i }, drawGraph: function () { var t = this, e = this.options, i = [["graph", e.lineColor || this.color]], n = e.lineWidth, s = e.dashStyle, o = "square" !== e.linecap, r = this.getGraphPath(), a = e.negativeColor; a && i.push(["graphNeg", a]), Vt(i, function (i, a) { var h = i[0], l = t[h]; l ? (ee(l), l.animate({ d: r })) : n && r.length && (l = { stroke: i[1], "stroke-width": n, fill: Et, zIndex: 1 }, s ? l.dashstyle = s : o && (l["stroke-linecap"] = l["stroke-linejoin"] = "round"), t[h] = t.chart.renderer.path(r).attr(l).add(t.group).shadow(!a && e.shadow)) }) }, clipNeg: function () { var t, e = this.options, i = this.chart, n = i.renderer, s = e.negativeColor || e.negativeFillColor, o = this.graph, r = this.area, a = this.posClip, h = this.negClip; t = i.chartWidth; var l = i.chartHeight, c = ut(t, l), d = this.yAxis; s && (o || r) && ((s = ct(d.toPixels(e.threshold || 0, !0))) < 0 && (c -= s), e = { x: 0, y: 0, width: c, height: s }, c = { x: 0, y: s, width: c, height: c }, i.inverted && (e.height = c.y = i.plotWidth - s, n.isVML && (e = { x: i.plotWidth - s - i.plotLeft, y: 0, width: t, height: l }, c = { x: s + i.plotLeft - t, y: 0, width: i.plotLeft + s, height: t })), d.reversed ? (i = c, t = e) : (i = e, t = c), a ? (a.animate(i), h.animate(t)) : (this.posClip = a = n.clipRect(i), this.negClip = h = n.clipRect(t), o && this.graphNeg && (o.clip(a), this.graphNeg.clip(h)), r && (r.clip(a), this.areaNeg.clip(h)))) }, invertGroups: function () { function t() { var t = { width: e.yAxis.len, height: e.xAxis.len }; Vt(["group", "markerGroup"], function (i) { e[i] && e[i].attr(t).invert() }) } var e = this, i = e.chart; e.xAxis && ($t(i, "resize", t), $t(e, "destroy", function () { qt(i, "resize", t) }), t(), e.invertGroups = t) }, plotGroup: function (t, e, i, n, s) { var o = this[t], r = !o; return r && (this[t] = o = this.chart.renderer.g(e).attr({ visibility: i, zIndex: n || .1 }).add(s)), o[r ? "attr" : "animate"](this.getPlotBox()), o }, getPlotBox: function () { var t = this.chart, e = this.xAxis, i = this.yAxis; return t.inverted && (e = i, i = this.xAxis), { translateX: e ? e.left : t.plotLeft, translateY: i ? i.top : t.plotTop, scaleX: 1, scaleY: 1 } }, render: function () { var t, e = this, i = e.chart, n = e.options, s = (t = n.animation) && !!e.animate && i.renderer.isSVG && u(t.duration, 500) || 0, o = e.visible ? "visible" : "hidden", r = n.zIndex, a = e.hasRendered, h = i.seriesGroup; t = e.plotGroup("group", "series", o, r, h), e.markerGroup = e.plotGroup("markerGroup", "markers", o, r, h), s && e.animate(!0), e.getAttribs(), t.inverted = !!e.isCartesian && i.inverted, e.drawGraph && (e.drawGraph(), e.clipNeg()), e.drawDataLabels && e.drawDataLabels(), e.visible && e.drawPoints(), e.drawTracker && !1 !== e.options.enableMouseTracking && e.drawTracker(), i.inverted && e.invertGroups(), !1 !== n.clip && !e.sharedClipKey && !a && t.clip(i.clipRect), s && e.animate(), a || (s ? e.animationTimeout = setTimeout(function () { e.afterAnimate() }, s) : e.afterAnimate()), e.isDirty = e.isDirtyData = !1, e.hasRendered = !0 }, redraw: function () { var t = this.chart, e = this.isDirtyData, i = this.group, n = this.xAxis, s = this.yAxis; i && (t.inverted && i.attr({ width: t.plotWidth, height: t.plotHeight }), i.animate({ translateX: u(n && n.left, t.plotLeft), translateY: u(s && s.top, t.plotTop) })), this.translate(), this.setTooltipPoints && this.setTooltipPoints(!0), this.render(), e && Jt(this, "updatedData") } }, E.prototype = { destroy: function () { L(this, this.axis) }, render: function (t) { var e = this.options, i = (i = e.format) ? b(i, this) : e.formatter.call(this); this.label ? this.label.attr({ text: i, visibility: "hidden" }) : this.label = this.axis.chart.renderer.text(i, null, null, e.useHTML).css(e.style).attr({ align: this.textAlign, rotation: e.rotation, visibility: "hidden" }).add(t) }, setOffset: function (t, e) { var i = (r = this.axis).chart, n = i.inverted, s = this.isNegative, o = r.translate(r.usePercentage ? 100 : this.total, 0, 0, 0, 1), r = r.translate(0), a = (r = gt(o - r), i.xAxis[0].translate(this.x) + t), h = i.plotHeight; s = { x: n ? s ? o : o - r : a, y: n ? h - a - e : s ? h - o - r : h - o, width: n ? r : e, height: n ? e : r }; (n = this.label) && (n.align(this.alignOptions, null, s), s = n.alignAttr, n[!1 === this.options.crop || i.isInsidePlot(s.x, s.y) ? "show" : "hide"](!0)) } }, R.prototype.buildStacks = function () { var t = this.series, e = u(this.options.reversedStacks, !0), i = t.length; if (!this.isXAxis) { for (this.usePercentage = !1; i--;)t[e ? i : t.length - i - 1].setStackedPoints(); if (this.usePercentage) for (i = 0; i < t.length; i++)t[i].setPercentStacks() } }, R.prototype.renderStackTotals = function () { var t, e, i = this.chart, n = i.renderer, s = this.stacks, o = this.stackTotalGroup; for (t in o || (this.stackTotalGroup = o = n.g("stack-labels").attr({ visibility: "visible", zIndex: 6 }).add()), o.translate(i.plotLeft, i.plotTop), s) for (e in i = s[t]) i[e].render(o) }, ke.prototype.setStackedPoints = function () { if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) { var t, e, i, n, s, o, r = this.processedXData, a = this.processedYData, h = [], l = a.length, c = (p = this.options).threshold, d = p.stack, p = p.stacking, u = this.stackKey, f = "-" + u, g = this.negStacks, m = this.yAxis, y = m.stacks, x = m.oldStacks; for (n = 0; n < l; n++)s = r[n], o = a[n], i = this.index + "," + n, y[e = (t = g && o < c) ? f : u] || (y[e] = {}), y[e][s] || (x[e] && x[e][s] ? (y[e][s] = x[e][s], y[e][s].total = null) : y[e][s] = new E(m, m.options.stackLabels, t, s, d)), (e = y[e][s]).points[i] = [e.cum || 0], "percent" === p ? (t = t ? u : f, g && y[t] && y[t][s] ? (t = y[t][s], e.total = t.total = ut(t.total, e.total) + gt(o) || 0) : e.total = D(e.total + (gt(o) || 0))) : e.total = D(e.total + (o || 0)), e.cum = (e.cum || 0) + (o || 0), e.points[i].push(e.cum), h[n] = e.cum; "percent" === p && (m.usePercentage = !0), this.stackedYData = h, m.oldStacks = {} } }, ke.prototype.setPercentStacks = function () { var t = this, e = t.stackKey, i = t.yAxis.stacks, n = t.processedXData; Vt([e, "-" + e], function (e) { for (var s, o, r = n.length; r--;)s = n[r], (s = (o = i[e] && i[e][s]) && o.points[t.index + "," + r]) && (o = o.total ? 100 / o.total : 0, s[0] = D(s[0] * o), s[1] = D(s[1] * o), t.stackedYData[r] = s[1]) }) }, t(X.prototype, { addSeries: function (t, e, i) { var n, s = this; return t && (e = u(e, !0), Jt(s, "addSeries", { options: t }, function () { n = s.initSeries(t), s.isDirtyLegend = !0, s.linkSeries(), e && s.redraw(i) })), n }, addAxis: function (t, i, n, s) { var o = i ? "xAxis" : "yAxis", r = this.options; new R(this, e(t, { index: this[o].length, isX: i })), r[o] = p(r[o] || {}), r[o].push(t), u(n, !0) && this.redraw(s) }, showLoading: function (e) { var i = this.options, n = this.loadingDiv, s = i.loading; n || (this.loadingDiv = n = g(Xt, { className: "highcharts-loading" }, t(s.style, { zIndex: 10, display: Et }), this.container), this.loadingSpan = g("span", null, s.labelStyle, n)), this.loadingSpan.innerHTML = e || i.lang.loading, this.loadingShown || (f(n, { opacity: 0, display: "", left: this.plotLeft + "px", top: this.plotTop + "px", width: this.plotWidth + "px", height: this.plotHeight + "px" }), te(n, { opacity: s.style.opacity }, { duration: s.showDuration || 0 }), this.loadingShown = !0) }, hideLoading: function () { var t = this.options, e = this.loadingDiv; e && te(e, { opacity: 0 }, { duration: t.loading.hideDuration || 100, complete: function () { f(e, { display: Et }) } }), this.loadingShown = !1 } }), t(be.prototype, { update: function (t, e, i) { var n, o = this, r = o.series, a = o.graphic, h = r.data, l = r.chart, c = r.options; e = u(e, !0); o.firePointEvent("update", { options: t }, function () { o.applyOptions(t), s(t) && (r.getAttribs(), a && (t && t.marker && t.marker.symbol ? o.graphic = a.destroy() : a.attr(o.pointAttr[o.state || ""])), t && t.dataLabels && o.dataLabel && (o.dataLabel = o.dataLabel.destroy())), n = jt(o, h), r.updateParallelArrays(o, n), c.data[n] = o.options, r.isDirty = r.isDirtyData = !0, !r.fixedBox && r.hasCartesianSeries && (l.isDirtyBox = !0), "point" === c.legendType && l.legend.destroyItem(o), e && l.redraw(i) }) }, remove: function (t, e) { var i, n = this, s = n.series, o = s.points, r = s.chart, a = s.data; I(e, r), t = u(t, !0), n.firePointEvent("remove", null, function () { i = jt(n, a), a.length === o.length && o.splice(i, 1), a.splice(i, 1), s.options.data.splice(i, 1), s.updateParallelArrays(n, "splice", i, 1), n.destroy(), s.isDirty = !0, s.isDirtyData = !0, t && r.redraw() }) } }), t(ke.prototype, { addPoint: function (t, e, i, n) { var s, o = this.options, r = this.data, a = this.graph, h = this.area, l = this.chart, c = this.xAxis && this.xAxis.names, d = a && a.shift || 0, p = o.data, f = this.xData; if (I(n, l), i && Vt([a, h, this.graphNeg, this.areaNeg], function (t) { t && (t.shift = d + 1) }), h && (h.isArea = !0), e = u(e, !0), n = { series: this }, this.pointClass.prototype.applyOptions.apply(n, [t]), a = n.x, h = f.length, this.requireSorting && a < f[h - 1]) for (s = !0; h && f[h - 1] > a;)h--; this.updateParallelArrays(n, "splice", h, 0, 0), this.updateParallelArrays(n, h), c && (c[a] = n.name), p.splice(h, 0, t), s && (this.data.splice(h, 0, null), this.processData()), "point" === o.legendType && this.generatePoints(), i && (r[0] && r[0].remove ? r[0].remove(!1) : (r.shift(), this.updateParallelArrays(n, "shift"), p.shift())), this.isDirtyData = this.isDirty = !0, e && (this.getAttribs(), l.redraw()) }, remove: function (t, e) { var i = this, n = i.chart; t = u(t, !0); i.isRemoving || (i.isRemoving = !0, Jt(i, "remove", null, function () { i.destroy(), n.isDirtyLegend = n.isDirtyBox = !0, n.linkSeries(), t && n.redraw(e) })), i.isRemoving = !1 }, update: function (i, n) { var s, o = this.chart, r = this.type, a = Wt[r].prototype; i = e(this.userOptions, { animation: !1, index: this.index, pointStart: this.xData[0] }, { data: this.options.data }, i); for (s in this.remove(!1), a) a.hasOwnProperty(s) && (this[s] = H); t(this, Wt[i.type || r].prototype), this.init(o, i), u(n, !0) && o.redraw(!1) } }), t(R.prototype, { update: function (i, n) { var s = this.chart; i = s.options[this.coll][this.options.index] = e(this.userOptions, i); this.destroy(!0), this._addedPlotLB = H, this.init(s, t(i, { events: H })), s.isDirtyBox = !0, u(n, !0) && s.redraw() }, remove: function (t) { for (var e = this.chart, i = this.coll, n = this.series, s = n.length; s--;)n[s] && n[s].remove(!1); l(e.axes, this), l(e[i], this), e.options[i].splice(this.options.index, 1), Vt(e[i], function (t, e) { t.options.index = e }), this.destroy(), e.isDirtyBox = !0, u(t, !0) && e.redraw() }, setTitle: function (t, e) { this.update({ title: t }, e) }, setCategories: function (t, e) { this.update({ categories: t }, e) } }), de = m(ke), Wt.line = de, ie.area = e(ne, { threshold: 0 }); var we = m(ke, { type: "area", getSegments: function () { var t, e, i, n, s, o = [], r = [], a = [], h = this.xAxis, l = this.yAxis, c = l.stacks[this.stackKey], d = {}, p = this.points, u = this.options.connectNulls; if (this.options.stacking && !this.cropped) { for (n = 0; n < p.length; n++)d[p[n].x] = p[n]; for (s in c) null !== c[s].total && a.push(+s); a.sort(function (t, e) { return t - e }), Vt(a, function (n) { (!u || d[n] && null !== d[n].y) && (d[n] ? r.push(d[n]) : (t = h.translate(n), i = c[n].percent ? c[n].total ? 100 * c[n].cum / c[n].total : 0 : c[n].cum, e = l.toPixels(i, !0), r.push({ y: null, plotX: t, clientX: t, plotY: e, yBottom: e, onMouseOver: zt }))) }), r.length && o.push(r) } else ke.prototype.getSegments.call(this), o = this.segments; this.segments = o }, getSegmentPath: function (t) { var e, i = ke.prototype.getSegmentPath.call(this, t), n = [].concat(i), s = this.options; e = i.length; var o, r = this.yAxis.getThreshold(s.threshold); if (3 === e && n.push("L", i[1], i[2]), s.stacking && !this.closedStacks) for (e = t.length - 1; e >= 0; e--)o = u(t[e].yBottom, r), e < t.length - 1 && s.step && n.push(t[e + 1].plotX, o), n.push(t[e].plotX, o); else this.closeSegment(n, t, r); return this.areaPath = this.areaPath.concat(n), i }, closeSegment: function (t, e, i) { t.push("L", e[e.length - 1].plotX, i, "L", e[0].plotX, i) }, drawGraph: function () { this.areaPath = [], ke.prototype.drawGraph.apply(this); var t = this, e = this.areaPath, i = this.options, n = i.negativeColor, s = i.negativeFillColor, o = [["area", this.color, i.fillColor]]; (n || s) && o.push(["areaNeg", n, s]), Vt(o, function (n) { var s = n[0], o = t[s]; o ? o.animate({ d: e }) : t[s] = t.chart.renderer.path(e).attr({ fill: u(n[2], ae(n[1]).setOpacity(u(i.fillOpacity, .75)).get()), zIndex: 0 }).add(t.group) }) }, drawLegendSymbol: Nt.drawRectangle }); Wt.area = we, ie.spline = e(ne), de = m(ke, { type: "spline", getPointSpline: function (t, e, i) { var n, s, o, r, a, h = e.plotX, l = e.plotY, c = t[i - 1], d = t[i + 1]; c && d && (t = c.plotY, o = d.plotX, r = (1.5 * l + (d = d.plotY)) / 2.5, r += a = (r - (s = (1.5 * l + t) / 2.5)) * ((o = (1.5 * h + o) / 2.5) - h) / (o - (n = (1.5 * h + c.plotX) / 2.5)) + l - r, (s += a) > t && s > l ? r = 2 * l - (s = ut(t, l)) : s < t && s < l && (r = 2 * l - (s = ft(t, l))), r > d && r > l ? s = 2 * l - (r = ut(d, l)) : r < d && r < l && (s = 2 * l - (r = ft(d, l))), e.rightContX = o, e.rightContY = r); return i ? (e = ["C", c.rightContX || c.plotX, c.rightContY || c.plotY, n || h, s || l, h, l], c.rightContX = c.rightContY = null) : e = ["M", h, l], e } }), Wt.spline = de, ie.areaspline = e(ie.area), de = m(de, { type: "areaspline", closedStacks: !0, getSegmentPath: (we = we.prototype).getSegmentPath, closeSegment: we.closeSegment, drawGraph: we.drawGraph, drawLegendSymbol: Nt.drawRectangle }), Wt.areaspline = de, ie.column = e(ne, { borderColor: "#FFFFFF", borderRadius: 0, groupPadding: .2, marker: null, pointPadding: .1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { brightness: .1, shadow: !1, halo: !1 }, select: { color: "#C0C0C0", borderColor: "#000000", shadow: !1 } }, dataLabels: { align: null, verticalAlign: null, y: null }, stickyTracking: !1, tooltip: { distance: 6 }, threshold: 0 }), de = m(ke, { type: "column", pointAttrToOptions: { stroke: "borderColor", fill: "color", r: "borderRadius" }, cropShoulder: 0, trackerGroups: ["group", "dataLabelsGroup"], negStacks: !0, init: function () { ke.prototype.init.apply(this, arguments); var t = this, e = t.chart; e.hasRendered && Vt(e.series, function (e) { e.type === t.type && (e.isDirty = !0) }) }, getColumnMetrics: function () { var t, e, i = this, n = i.options, s = i.xAxis, o = i.yAxis, r = s.reversed, a = {}, h = 0; !1 === n.grouping ? h = 1 : Vt(i.chart.series, function (n) { var s = n.options, r = n.yAxis; n.type === i.type && n.visible && o.len === r.len && o.pos === r.pos && (s.stacking ? (t = n.stackKey, a[t] === H && (a[t] = h++), e = a[t]) : !1 !== s.grouping && (e = h++), n.columnIndex = e) }); var l = (s = ft(gt(s.transA) * (s.ordinalSlope || n.pointRange || s.closestPointRange || s.tickInterval || 1), s.len)) * n.groupPadding, d = (s - 2 * l) / h, p = u(p = n.pointWidth, d - 2 * (n = c(p) ? (d - p) / 2 : d * n.pointPadding)); return i.columnMetrics = { width: p, offset: n + (l + ((r ? h - (i.columnIndex || 0) : i.columnIndex) || 0) * d - s / 2) * (r ? -1 : 1) } }, translate: function () { var t = this, e = t.chart, i = t.options, n = t.borderWidth = u(i.borderWidth, t.activePointCount > .5 * t.xAxis.len ? 0 : 1), s = t.yAxis, o = t.translatedThreshold = s.getThreshold(i.threshold), r = u(i.minPointLength, 5), a = (i = t.getColumnMetrics()).width, h = t.barW = pt(ut(a, 1 + 2 * n)), l = t.pointXOffset = i.offset, c = -(n % 2 ? .5 : 0), d = n % 2 ? .5 : 1; e.renderer.isVML && e.inverted && (d += 1), ke.prototype.translate.apply(t), Vt(t.points, function (i) { var n, p = u(i.yBottom, o), f = ft(ut(-999 - p, i.plotY), s.len + 999 + p), g = i.plotX + l, m = h, y = ft(f, p); n = ut(f, p) - y, gt(n) < r && r && (n = r, y = ct(gt(y - o) > r ? p - r : o - (s.translate(i.y, 0, 1, 0, 1) <= o ? r : 0))), i.barX = g, i.pointWidth = a, i.tooltipPos = e.inverted ? [s.len - f, t.xAxis.len - g - m / 2] : [g + m / 2, f], p = gt(g) < .5, m = ct(g + m) + c, m -= g = ct(g) + c, f = gt(y) < .5, n = ct(y + n) + d, n -= y = ct(y) + d, p && (g += 1, m -= 1), f && (y -= 1, n += 1), i.shapeType = "rect", i.shapeArgs = { x: g, y: y, width: m, height: n } }) }, getSymbol: zt, drawLegendSymbol: Nt.drawRectangle, drawGraph: zt, drawPoints: function () { var t, i, n, s = this, o = this.chart, r = s.options, a = o.renderer, h = r.animationLimit || 250; Vt(s.points, function (l) { var d = l.plotY, p = l.graphic; d === H || isNaN(d) || null === l.y ? p && (l.graphic = p.destroy()) : (t = l.shapeArgs, n = c(s.borderWidth) ? { "stroke-width": s.borderWidth } : {}, i = l.pointAttr[l.selected ? "select" : ""] || s.pointAttr[""], p ? (ee(p), p.attr(n)[o.pointCount < h ? "animate" : "attr"](e(t))) : l.graphic = a[l.shapeType](t).attr(i).attr(n).add(s.group).shadow(r.shadow, null, r.stacking && !r.borderRadius)) }) }, animate: function (t) { var e = this.yAxis, i = this.options, n = this.chart.inverted, s = {}; Ct && (t ? (s.scaleY = .001, t = ft(e.pos + e.len, ut(e.pos, e.toPixels(i.threshold))), n ? s.translateX = t - e.len : s.translateY = t, this.group.attr(s)) : (s.scaleY = 1, s[n ? "translateX" : "translateY"] = e.pos, this.group.animate(s, this.options.animation), this.animate = null)) }, remove: function () { var t = this, e = t.chart; e.hasRendered && Vt(e.series, function (e) { e.type === t.type && (e.isDirty = !0) }), ke.prototype.remove.apply(t, arguments) } }), Wt.column = de, ie.bar = e(ie.column), we = m(de, { type: "bar", inverted: !0 }), Wt.bar = we, ie.scatter = e(ne, { lineWidth: 0, tooltip: { headerFormat: '<span style="color:{series.color}">●</span> <span style="font-size: 10px;"> {series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>" }, stickyTracking: !1 }), we = m(ke, { type: "scatter", sorted: !1, requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["markerGroup"], takeOrdinalPosition: !1, singularTooltips: !0, drawGraph: function () { this.options.lineWidth && ke.prototype.drawGraph.call(this) } }), Wt.scatter = we, ie.pie = e(ne, { borderColor: "#FFFFFF", borderWidth: 1, center: [null, null], clip: !1, colorByPoint: !0, dataLabels: { distance: 30, enabled: !0, formatter: function () { return this.point.name } }, ignoreHiddenPoint: !0, legendType: "point", marker: null, size: null, showInLegend: !1, slicedOffset: 10, states: { hover: { brightness: .1, shadow: !1 } }, stickyTracking: !1, tooltip: { followPointer: !0 } }), ne = { type: "pie", isCartesian: !1, pointClass: m(be, { init: function () { be.prototype.init.apply(this, arguments); var e, i = this; return i.y < 0 && (i.y = null), t(i, { visible: !1 !== i.visible, name: u(i.name, "Slice") }), e = function (t) { i.slice("select" === t.type) }, $t(i, "select", e), $t(i, "unselect", e), i }, setVisible: function (t) { var e = this, i = e.series, n = i.chart; e.visible = e.options.visible = t = t === H ? !e.visible : t, i.options.data[jt(e, i.data)] = e.options, Vt(["graphic", "dataLabel", "connector", "shadowGroup"], function (i) { e[i] && e[i][t ? "show" : "hide"](!0) }), e.legendItem && n.legend.colorizeItem(e, t), !i.isDirty && i.options.ignoreHiddenPoint && (i.isDirty = !0, n.redraw()) }, slice: function (t, e, i) { var n = this.series; I(i, n.chart), u(e, !0), this.sliced = this.options.sliced = t = c(t) ? t : !this.sliced, n.options.data[jt(this, n.data)] = this.options, t = t ? this.slicedTranslation : { translateX: 0, translateY: 0 }, this.graphic.animate(t), this.shadowGroup && this.shadowGroup.animate(t) }, haloPath: function (t) { var e = this.shapeArgs, i = this.series.chart; return this.series.chart.renderer.symbols.arc(i.plotLeft + e.x, i.plotTop + e.y, e.r + t, e.r + t, { innerR: this.shapeArgs.r, start: e.start, end: e.end }) } }), requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["group", "dataLabelsGroup"], axisTypes: [], pointAttrToOptions: { stroke: "borderColor", "stroke-width": "borderWidth", fill: "color" }, singularTooltips: !0, getColor: zt, animate: function (t) { var e = this, i = e.points, n = e.startAngleRad; t || (Vt(i, function (t) { var i = t.graphic; t = t.shapeArgs; i && (i.attr({ r: e.center[3] / 2, start: n, end: n }), i.animate({ r: t.r, start: t.start, end: t.end }, e.options.animation)) }), e.animate = null) }, setData: function (t, e, i, n) { ke.prototype.setData.call(this, t, !1, i, n), this.processData(), this.generatePoints(), u(e, !0) && this.chart.redraw(i) }, generatePoints: function () { var t, e, i, n, s = 0, o = this.options.ignoreHiddenPoint; for (ke.prototype.generatePoints.call(this), i = (e = this.points).length, t = 0; t < i; t++)n = e[t], s += o && !n.visible ? 0 : n.y; for (this.total = s, t = 0; t < i; t++)(n = e[t]).percentage = s > 0 ? n.y / s * 100 : 0, n.total = s }, translate: function (t) { this.generatePoints(); var e, i, n, s, o, r = 0, a = (f = this.options).slicedOffset, h = a + f.borderWidth, l = f.startAngle || 0, c = this.startAngleRad = xt / 180 * (l - 90), d = (l = (this.endAngleRad = xt / 180 * (u(f.endAngle, l + 360) - 90)) - c, this.points), p = f.dataLabels.distance, f = f.ignoreHiddenPoint, g = d.length; for (t || (this.center = t = this.getCenter()), this.getX = function (e, i) { return n = lt.asin(ft((e - t[1]) / (t[2] / 2 + p), 1)), t[0] + (i ? -1 : 1) * mt(n) * (t[2] / 2 + p) }, s = 0; s < g; s++)o = d[s], e = c + r * l, f && !o.visible || (r += o.percentage / 100), i = c + r * l, o.shapeType = "arc", o.shapeArgs = { x: t[0], y: t[1], r: t[2] / 2, innerR: t[3] / 2, start: ct(1e3 * e) / 1e3, end: ct(1e3 * i) / 1e3 }, (n = (i + e) / 2) > 1.5 * xt ? n -= 2 * xt : n < -xt / 2 && (n += 2 * xt), o.slicedTranslation = { translateX: ct(mt(n) * a), translateY: ct(yt(n) * a) }, e = mt(n) * t[2] / 2, i = yt(n) * t[2] / 2, o.tooltipPos = [t[0] + .7 * e, t[1] + .7 * i], o.half = n < -xt / 2 || n > xt / 2 ? 1 : 0, o.angle = n, h = ft(h, p / 2), o.labelPos = [t[0] + e + mt(n) * p, t[1] + i + yt(n) * p, t[0] + e + mt(n) * h, t[1] + i + yt(n) * h, t[0] + e, t[1] + i, p < 0 ? "center" : o.half ? "right" : "left", n] }, drawGraph: null, drawPoints: function () { var e, i, n, s, o = this, r = o.chart.renderer, a = o.options.shadow; a && !o.shadowGroup && (o.shadowGroup = r.g("shadow").add(o.group)), Vt(o.points, function (h) { i = h.graphic, s = h.shapeArgs, n = h.shadowGroup, a && !n && (n = h.shadowGroup = r.g("shadow").add(o.shadowGroup)), e = h.sliced ? h.slicedTranslation : { translateX: 0, translateY: 0 }, n && n.attr(e), i ? i.animate(t(s, e)) : h.graphic = i = r[h.shapeType](s).setRadialReference(o.center).attr(h.pointAttr[h.selected ? "select" : ""]).attr({ "stroke-linejoin": "round" }).attr(e).add(o.group).shadow(a, n), void 0 !== h.visible && h.setVisible(h.visible) }) }, sortByAngle: function (t, e) { t.sort(function (t, i) { return void 0 !== t.angle && (i.angle - t.angle) * e }) }, drawLegendSymbol: Nt.drawRectangle, getCenter: he.getCenter, getSymbol: zt }, ne = m(ke, ne), Wt.pie = ne, ke.prototype.drawDataLabels = function () { var i, n, s, o, r = this, a = r.options, h = a.cursor, l = a.dataLabels, d = r.points; (l.enabled || r._hasPointLabels) && (r.dlProcessOptions && r.dlProcessOptions(l), o = r.plotGroup("dataLabelsGroup", "data-labels", "hidden", l.zIndex || 6), !r.hasRendered && u(l.defer, !0) && (o.attr({ opacity: 0 }), $t(r, "afterAnimate", function () { r.dataLabelsGroup.show()[a.animation ? "animate" : "attr"]({ opacity: 1 }, { duration: 200 }) })), n = l, Vt(d, function (a) { var d, p, f, g = a.dataLabel, m = a.connector, y = !0; if (d = u((i = a.options && a.options.dataLabels) && i.enabled, n.enabled), g && !d) a.dataLabel = g.destroy(); else if (d) { if (d = (l = e(n, i)).rotation, p = a.getLabelConfig(), s = l.format ? b(l.format, p) : l.formatter.call(p, l), l.style.color = u(l.color, l.style.color, r.color, "black"), g) c(s) ? (g.attr({ text: s }), y = !1) : (a.dataLabel = g = g.destroy(), m && (a.connector = m.destroy())); else if (c(s)) { for (f in g = { fill: l.backgroundColor, stroke: l.borderColor, "stroke-width": l.borderWidth, r: l.borderRadius || 0, rotation: d, padding: l.padding, zIndex: 1 }) g[f] === H && delete g[f]; g = a.dataLabel = r.chart.renderer[d ? "text" : "label"](s, 0, -999, null, null, null, l.useHTML).attr(g).css(t(l.style, h && { cursor: h })).add(o).shadow(l.shadow) } g && r.alignDataLabel(a, g, l, null, y) } })) }, ke.prototype.alignDataLabel = function (e, i, n, s, o) { var r = this.chart, a = r.inverted, h = u(e.plotX, -999), l = u(e.plotY, -999), c = i.getBBox(); (e = this.visible && (e.series.forceDL || r.isInsidePlot(h, ct(l), a) || s && r.isInsidePlot(h, a ? s.x + 1 : s.y + s.height - 1, a))) && (s = t({ x: a ? r.plotWidth - l : h, y: ct(a ? r.plotHeight - h : l), width: 0, height: 0 }, s), t(n, { width: c.width, height: c.height }), n.rotation ? (a = { align: n.align, x: s.x + n.x + s.width / 2, y: s.y + n.y + s.height / 2 }, i[o ? "attr" : "animate"](a)) : (i.align(n, null, s), a = i.alignAttr, "justify" === u(n.overflow, "justify") ? this.justifyDataLabel(i, n, a, c, s, o) : u(n.crop, !0) && (e = r.isInsidePlot(a.x, a.y) && r.isInsidePlot(a.x + c.width, a.y + c.height)))), e || (i.attr({ y: -999 }), i.placed = !1) }, ke.prototype.justifyDataLabel = function (t, e, i, n, s, o) { var r, a, h = this.chart, l = e.align, c = e.verticalAlign; (r = i.x) < 0 && ("right" === l ? e.align = "left" : e.x = -r, a = !0), (r = i.x + n.width) > h.plotWidth && ("left" === l ? e.align = "right" : e.x = h.plotWidth - r, a = !0), (r = i.y) < 0 && ("bottom" === c ? e.verticalAlign = "top" : e.y = -r, a = !0), (r = i.y + n.height) > h.plotHeight && ("top" === c ? e.verticalAlign = "bottom" : e.y = h.plotHeight - r, a = !0), a && (t.placed = !o, t.align(e, null, s)) }, Wt.pie && (Wt.pie.prototype.drawDataLabels = function () { var t, e, i, n, s, o, r, a, h, l, c, d, p = this, f = p.data, g = p.chart, m = p.options.dataLabels, y = u(m.connectorPadding, 10), x = u(m.connectorWidth, 1), v = g.plotWidth, b = (g = g.plotHeight, u(m.softConnector, !0)), k = m.distance, w = p.center, S = w[2] / 2, T = w[1], P = k > 0, L = [[], []], C = [0, 0, 0, 0], M = function (t, e) { return e.y - t.y }; if (p.visible && (m.enabled || p._hasPointLabels)) { for (ke.prototype.drawDataLabels.apply(p), Vt(f, function (t) { t.dataLabel && t.visible && L[t.half].push(t) }), c = 0; !r && f[c];)r = f[c] && f[c].dataLabel && (f[c].dataLabel.getBBox().height || 21), c++; for (c = 2; c--;) { f = []; var D, I = [], O = L[c], z = O.length; if (p.sortByAngle(O, c - .5), k > 0) { for (d = T - S - k; d <= T + S + k; d += r)f.push(d); if (z > (s = f.length)) { for ((t = [].concat(O)).sort(M), d = z; d--;)t[d].rank = d; for (d = z; d--;)O[d].rank >= s && O.splice(d, 1); z = O.length } for (d = 0; d < z; d++) { var B, R; for (t = O[d], o = t.labelPos, t = 9999, R = 0; R < s; R++)(B = gt(f[R] - o[1])) < t && (t = B, D = R); if (D < d && null !== f[d]) D = d; else for (s < z - d + D && null !== f[d] && (D = s - z + d); null === f[D];)D++; I.push({ i: D, y: f[D] }), f[D] = null } I.sort(M) } for (d = 0; d < z; d++)t = O[d], o = t.labelPos, n = t.dataLabel, l = !1 === t.visible ? "hidden" : "visible", t = o[1], k > 0 ? (D = (s = I.pop()).i, (t > (h = s.y) && null !== f[D + 1] || t < h && null !== f[D - 1]) && (h = t)) : h = t, a = m.justify ? w[0] + (c ? -1 : 1) * (S + k) : p.getX(0 === D || D === f.length - 1 ? t : h, c), n._attr = { visibility: l, align: o[6] }, n._pos = { x: a + m.x + ({ left: y, right: -y }[o[6]] || 0), y: h + m.y - 10 }, n.connX = a, n.connY = h, null === this.options.size && (s = n.width, a - s < y ? C[3] = ut(ct(s - a + y), C[3]) : a + s > v - y && (C[1] = ut(ct(a + s - v + y), C[1])), h - r / 2 < 0 ? C[0] = ut(ct(r / 2 - h), C[0]) : h + r / 2 > g && (C[2] = ut(ct(h + r / 2 - g), C[2]))) } (0 === A(C) || this.verifyDataLabelOverflow(C)) && (this.placeDataLabels(), P && x && Vt(this.points, function (t) { e = t.connector, o = t.labelPos, (n = t.dataLabel) && n._pos ? (l = n._attr.visibility, a = n.connX, h = n.connY, i = b ? ["M", a + ("left" === o[6] ? 5 : -5), h, "C", a, h, 2 * o[2] - o[4], 2 * o[3] - o[5], o[2], o[3], "L", o[4], o[5]] : ["M", a + ("left" === o[6] ? 5 : -5), h, "L", o[2], o[3], "L", o[4], o[5]], e ? (e.animate({ d: i }), e.attr("visibility", l)) : t.connector = e = p.chart.renderer.path(i).attr({ "stroke-width": x, stroke: m.connectorColor || t.color || "#606060", visibility: l }).add(p.dataLabelsGroup)) : e && (t.connector = e.destroy()) })) } }, Wt.pie.prototype.placeDataLabels = function () { Vt(this.points, function (t) { var e; (t = t.dataLabel) && ((e = t._pos) ? (t.attr(t._attr), t[t.moved ? "animate" : "attr"](e), t.moved = !0) : t && t.attr({ y: -999 })) }) }, Wt.pie.prototype.alignDataLabel = zt, Wt.pie.prototype.verifyDataLabelOverflow = function (t) { var e, i = this.center, n = this.options, s = n.center, o = n = n.minSize || 80; return null !== s[0] ? o = ut(i[2] - ut(t[1], t[3]), n) : (o = ut(i[2] - t[1] - t[3], n), i[0] += (t[3] - t[1]) / 2), null !== s[1] ? o = ut(ft(o, i[2] - ut(t[0], t[2])), n) : (o = ut(ft(o, i[2] - t[0] - t[2]), n), i[1] += (t[0] - t[2]) / 2), o < i[2] ? (i[2] = o, this.translate(i), Vt(this.points, function (t) { t.dataLabel && (t.dataLabel._pos = null) }), this.drawDataLabels && this.drawDataLabels()) : e = !0, e }), Wt.column && (Wt.column.prototype.alignDataLabel = function (t, i, n, s, o) { var r = this.chart, a = r.inverted, h = t.dlBox || t.shapeArgs, l = t.below || t.plotY > u(this.translatedThreshold, r.plotSizeY), c = u(n.inside, !!this.options.stacking); h && (s = e(h), a && (s = { x: r.plotWidth - s.y - s.height, y: r.plotHeight - s.x - s.width, width: s.height, height: s.width }), !c) && (a ? (s.x += l ? 0 : s.width, s.width = 0) : (s.y += l ? s.height : 0, s.height = 0)), n.align = u(n.align, !a || c ? "center" : l ? "right" : "left"), n.verticalAlign = u(n.verticalAlign, a || c ? "middle" : l ? "top" : "bottom"), ke.prototype.alignDataLabel.call(this, t, i, n, s, o) }), ne = Yt.TrackerMixin = { drawTrackerPoint: function () { var t = this, e = t.chart, i = e.pointer, n = t.options.cursor, s = n && { cursor: n }, o = function (i) { var n, s = i.target; for (e.hoverSeries !== t && t.onMouseOver(); s && !n;)n = s.point, s = s.parentNode; n !== H && n !== e.hoverPoint && n.onMouseOver(i) }; Vt(t.points, function (t) { t.graphic && (t.graphic.element.point = t), t.dataLabel && (t.dataLabel.element.point = t) }), t._hasTracking || (Vt(t.trackerGroups, function (e) { t[e] && (t[e].addClass("highcharts-tracker").on("mouseover", o).on("mouseout", function (t) { i.onTrackerMouseOut(t) }).css(s), W) && t[e].on("touchstart", o) }), t._hasTracking = !0) }, drawTrackerGraph: function () { var t, e = this, i = e.options, n = i.trackByArea, s = [].concat(n ? e.areaPath : e.graphPath), o = s.length, r = e.chart, a = r.pointer, h = r.renderer, l = r.options.tooltip.snap, c = e.tracker, d = (p = i.cursor) && { cursor: p }, p = e.singlePoints, u = function () { r.hoverSeries !== e && e.onMouseOver() }, f = "rgba(192,192,192," + (Ct ? 1e-4 : .002) + ")"; if (o && !n) for (t = o + 1; t--;)"M" === s[t] && s.splice(t + 1, 0, s[t + 1] - l, s[t + 2], "L"), (t && "M" === s[t] || t === o) && s.splice(t, 0, "L", s[t - 2] + l, s[t - 1]); for (t = 0; t < p.length; t++)o = p[t], s.push("M", o.plotX - l, o.plotY, "L", o.plotX + l, o.plotY); c ? c.attr({ d: s }) : (e.tracker = h.path(s).attr({ "stroke-linejoin": "round", visibility: e.visible ? "visible" : "hidden", stroke: f, fill: n ? f : Et, "stroke-width": i.lineWidth + (n ? 0 : 2 * l), zIndex: 2 }).add(e.group), Vt([e.tracker, e.markerGroup], function (t) { t.addClass("highcharts-tracker").on("mouseover", u).on("mouseout", function (t) { a.onTrackerMouseOut(t) }).css(d), W && t.on("touchstart", u) })) } }, Wt.column && (de.prototype.drawTracker = ne.drawTrackerPoint), Wt.pie && (Wt.pie.prototype.drawTracker = ne.drawTrackerPoint), Wt.scatter && (we.prototype.drawTracker = ne.drawTrackerPoint), t(ve.prototype, { setItemEvents: function (t, e, i, n, s) { var o = this; (i ? e : t.legendGroup).on("mouseover", function () { t.setState("hover"), e.css(o.options.itemHoverStyle) }).on("mouseout", function () { e.css(t.visible ? n : s), t.setState() }).on("click", function (e) { var i = function () { t.setVisible() }; e = { browserEvent: e }; t.firePointEvent ? t.firePointEvent("legendItemClick", e, i) : Jt(t, "legendItemClick", e, i) }) }, createCheckboxForItem: function (t) { t.checkbox = g("input", { type: "checkbox", checked: t.selected, defaultChecked: t.selected }, this.options.itemCheckboxStyle, this.chart.container), $t(t.checkbox, "click", function (e) { Jt(t, "checkboxClick", { checked: e.target.checked }, function () { t.select() }) }) } }), N.legend.itemStyle.cursor = "pointer", t(X.prototype, { showResetZoom: function () { var t = this, e = N.lang, i = t.options.chart.resetZoomButton, n = i.theme, s = n.states, o = "chart" === i.relativeTo ? null : "plotBox"; this.resetZoomButton = t.renderer.button(e.resetZoom, null, null, function () { t.zoomOut() }, n, s && s.hover).attr({ align: i.position.align, title: e.resetZoomTitle }).add().align(i.position, !1, o) }, zoomOut: function () { var t = this; Jt(t, "selection", { resetSelection: !0 }, function () { t.zoom() }) }, zoom: function (t) { var e, i, n = this.pointer, o = !1; !t || t.resetSelection ? Vt(this.axes, function (t) { e = t.zoom() }) : Vt(t.xAxis.concat(t.yAxis), function (t) { var i = t.axis, s = i.isXAxis; (n[s ? "zoomX" : "zoomY"] || n[s ? "pinchX" : "pinchY"]) && (e = i.zoom(t.min, t.max), i.displayBtn && (o = !0)) }), i = this.resetZoomButton, o && !i ? this.showResetZoom() : !o && s(i) && (this.resetZoomButton = i.destroy()), e && this.redraw(u(this.options.chart.animation, t && t.animation, this.pointCount < 100)) }, pan: function (t, e) { var i, n = this, s = n.hoverPoints; s && Vt(s, function (t) { t.setState() }), Vt("xy" === e ? [1, 0] : [1], function (e) { var s = t[e ? "chartX" : "chartY"], o = n[e ? "xAxis" : "yAxis"][0], r = n[e ? "mouseDownX" : "mouseDownY"], a = (o.pointRange || 0) / 2, h = o.getExtremes(), l = o.toValue(r - s, !0) + a; r = o.toValue(r + n[e ? "plotWidth" : "plotHeight"] - s, !0) - a; o.series.length && l > ft(h.dataMin, h.min) && r < ut(h.dataMax, h.max) && (o.setExtremes(l, r, !1, !1, { trigger: "pan" }), i = !0), n[e ? "mouseDownX" : "mouseDownY"] = s }), i && n.redraw(!1), f(n.container, { cursor: "move" }) } }), t(be.prototype, { select: function (t, e) { var i = this, n = i.series, s = n.chart; t = u(t, !i.selected); i.firePointEvent(t ? "select" : "unselect", { accumulate: e }, function () { i.selected = i.options.selected = t, n.options.data[jt(i, n.data)] = i.options, i.setState(t && "select"), e || Vt(s.getSelectedPoints(), function (t) { t.selected && t !== i && (t.selected = t.options.selected = !1, n.options.data[jt(t, n.data)] = t.options, t.setState(""), t.firePointEvent("unselect")) }) }) }, onMouseOver: function (t) { var e = this.series, i = e.chart, n = i.tooltip, s = i.hoverPoint; s && s !== this && s.onMouseOut(), this.firePointEvent("mouseOver"), n && (!n.shared || e.noSharedTooltip) && n.refresh(this, t), this.setState("hover"), i.hoverPoint = this }, onMouseOut: function () { var t = this.series.chart, e = t.hoverPoints; e && -1 !== jt(this, e) || (this.firePointEvent("mouseOut"), this.setState(), t.hoverPoint = null) }, importEvents: function () { if (!this.hasImportedEvents) { var t, i = e(this.series.options.point, this.options).events; for (t in this.events = i, i) $t(this, t, i[t]); this.hasImportedEvents = !0 } }, setState: function (i, n) { var s, o = this.plotX, r = this.plotY, a = this.series, h = a.options.states, l = ie[a.type].marker && a.options.marker, c = l && !l.enabled, d = l && l.states[i], p = d && !1 === d.enabled, u = a.stateMarkerGraphic, f = this.marker || {}, g = a.chart, m = a.halo; i = i || ""; s = this.pointAttr[i] || a.pointAttr[i], i === this.state && !n || this.selected && "select" !== i || h[i] && !1 === h[i].enabled || i && (p || c && !1 === d.enabled) || i && f.states && f.states[i] && !1 === f.states[i].enabled || (this.graphic ? (l = l && this.graphic.symbolName && s.r, this.graphic.attr(e(s, l ? { x: o - l, y: r - l, width: 2 * l, height: 2 * l } : {})), u && u.hide()) : (i && d && (l = d.radius, f = f.symbol || a.symbol, u && u.currentSymbol !== f && (u = u.destroy()), u ? u[n ? "animate" : "attr"]({ x: o - l, y: r - l }) : f && (a.stateMarkerGraphic = u = g.renderer.symbol(f, o - l, r - l, 2 * l, 2 * l).attr(s).add(a.markerGroup), u.currentSymbol = f)), u && u[i && g.isInsidePlot(o, r, g.inverted) ? "show" : "hide"]()), (o = h[i] && h[i].halo) && o.size ? (m || (a.halo = m = g.renderer.path().add(a.seriesGroup)), m.attr(t({ fill: ae(this.color || a.color).setOpacity(o.opacity).get() }, o.attributes))[n ? "animate" : "attr"]({ d: this.haloPath(o.size) })) : m && m.attr({ d: [] }), this.state = i) }, haloPath: function (t) { var e = this.series, i = e.chart, n = e.getPlotBox(), s = i.inverted; return i.renderer.symbols.circle(n.translateX + (s ? e.yAxis.len - this.plotY : this.plotX) - t, n.translateY + (s ? e.xAxis.len - this.plotX : this.plotY) - t, 2 * t, 2 * t) } }), t(ke.prototype, { onMouseOver: function () { var t = this.chart, e = t.hoverSeries; e && e !== this && e.onMouseOut(), this.options.events.mouseOver && Jt(this, "mouseOver"), this.setState("hover"), t.hoverSeries = this }, onMouseOut: function () { var t = this.options, e = this.chart, i = e.tooltip, n = e.hoverPoint; n && n.onMouseOut(), this && t.events.mouseOut && Jt(this, "mouseOut"), i && !t.stickyTracking && (!i.shared || this.noSharedTooltip) && i.hide(), this.setState(), e.hoverSeries = null }, setState: function (t) { var e = this.options, i = this.graph, n = this.graphNeg, s = e.states; e = e.lineWidth, t = t || ""; this.state !== t && (this.state = t, s[t] && !1 === s[t].enabled || (t && (e = s[t].lineWidth || e + 1), i && !i.dashstyle && (t = { "stroke-width": e }, i.attr(t), n && n.attr(t)))) }, setVisible: function (t, e) { var i, n = this, s = n.chart, o = n.legendItem, r = s.options.chart.ignoreHiddenSeries, a = n.visible; i = (n.visible = t = n.userOptions.visible = t === H ? !a : t) ? "show" : "hide", Vt(["group", "dataLabelsGroup", "markerGroup", "tracker"], function (t) { n[t] && n[t][i]() }), s.hoverSeries === n && n.onMouseOut(), o && s.legend.colorizeItem(n, t), n.isDirty = !0, n.options.stacking && Vt(s.series, function (t) { t.options.stacking && t.visible && (t.isDirty = !0) }), Vt(n.linkedSeries, function (e) { e.setVisible(t, !1) }), r && (s.isDirtyBox = !0), !1 !== e && s.redraw(), Jt(n, i) }, setTooltipPoints: function (t) { var e, i, n, s, o = [], r = this.xAxis, a = r && r.getExtremes(), h = r ? r.tooltipLen || r.len : this.chart.plotSizeX, l = []; if (!1 !== this.options.enableMouseTracking && !this.singularTooltips) { for (t && (this.tooltipPoints = null), Vt(this.segments || this.points, function (t) { o = o.concat(t) }), r && r.reversed && (o = o.reverse()), this.orderTooltipPoints && this.orderTooltipPoints(o), t = o.length, s = 0; s < t; s++)if ((e = (r = o[s]).x) >= a.min && e <= a.max) for (n = o[s + 1], e = i === H ? 0 : i + 1, i = o[s + 1] ? ft(ut(0, dt((r.clientX + (n ? n.wrappedClientX || n.clientX : h)) / 2)), h) : h; e >= 0 && e <= i;)l[e++] = r; this.tooltipPoints = l } }, show: function () { this.setVisible(!0) }, hide: function () { this.setVisible(!1) }, select: function (t) { this.selected = t = t === H ? !this.selected : t, this.checkbox && (this.checkbox.checked = t), Jt(this, t ? "select" : "unselect") }, drawTracker: ne.drawTrackerGraph }), t(Yt, { Axis: R, Chart: X, Color: ae, Point: be, Tick: B, Renderer: G, Series: ke, SVGElement: z, SVGRenderer: ce, arrayMin: P, arrayMax: A, charts: Bt, dateFormat: F, format: b, pathAnim: j, getOptions: function () { return N }, hasBidiBug: Mt, isTouchDevice: At, numberFormat: y, seriesTypes: Wt, setOptions: function (t) { return N = e(!0, N, t), O(), N }, addEvent: $t, removeEvent: qt, createElement: g, discardElement: C, css: f, each: Vt, extend: t, map: Kt, merge: e, pick: u, splat: p, extendClass: m, pInt: i, wrap: v, svg: Ct, canvas: Dt, vml: !Ct && !Dt, product: "Highcharts", version: "4.0.1" }) }();